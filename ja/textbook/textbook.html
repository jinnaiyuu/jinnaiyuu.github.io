<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2016 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>ヒューリスティック探索: ドラフト</TITLE>
<META NAME="description" CONTENT="ヒューリスティック探索">
<META NAME="keywords" CONTENT="textbook">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2016">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="ods-book.css">

</HEAD>

<BODY text="#000000" bgcolor="#FFFFFF">

<DIV CLASS="navigation"><!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive" SRC="nx_grp_g.png"> 
<A NAME="tex2html23"
  HREF="https://sites.google.com/site/yuujinnaishomepage/jp/graph-search-algorithm">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev_g.png">   
<BR>
<B> Up:</B> <A NAME="tex2html24"
  HREF="https://sites.google.com/site/yuujinnaishomepage/jp/graph-search-algorithm">Yuu Jinnai</A>
<BR><BR></DIV>
<!--End of Navigation Panel-->

<P>
<H1 ALIGN=CENTER>ヒューリスティック探索: ドラフト</H1>
<P ALIGN=CENTER><STRONG>陣内　佑</STRONG>
<BR><I>理化学研究所 革新知能統合研究センター
<I>yuu.jinnai@riken.jp</I></I>
</P>
<HR>
この文章は私が書き途中のヒューリスティック探索の教科書の未校正のドラフトです。
内容の正しさは保証しません。
<BR>

<H2><A NAME="SECTION00100000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL CLASS="TofC">
<LI><A NAME="tex2html36"
  HREF="textbook.html#SECTION00200000000000000000">1. イントロダクション</A>
<LI><A NAME="tex2html37"
  HREF="textbook.html#SECTION00300000000000000000">2. 状態空間問題 (State-Space Problem)</A>
<LI><A NAME="tex2html38"
  HREF="textbook.html#SECTION00400000000000000000">3. 情報なし探索 (Blind Search)</A>
<LI><A NAME="tex2html39"
  HREF="textbook.html#SECTION00500000000000000000">4. ヒューリスティック探索 (Heuristic Search)</A>
<LI><A NAME="tex2html40"
  HREF="textbook.html#SECTION00600000000000000000">5. 自動行動計画問題 (Automated Planning Problem)</A>
<LI><A NAME="tex2html41"
  HREF="textbook.html#SECTION00700000000000000000">6. 実験評価</A>
<LI><A NAME="tex2html42"
  HREF="textbook.html#SECTION00800000000000000000">7. ヒューリスティック探索の派生</A>
<LI><A NAME="tex2html43"
  HREF="textbook.html#SECTION00900000000000000000">Index</A>
<LI><A NAME="tex2html44"
  HREF="textbook.html#SECTION001000000000000000000">Bibliography</A>
</UL>
<!--End of Table of Contents-->
<P>

<P>

<H1><A NAME="SECTION00200000000000000000"></A>
<A NAME="ch:introduction"></A><BR>
<SPAN CLASS="arabic">1</SPAN>. イントロダクション
</H1>

<P>
朝起きて、ごはんをよそい、味噌汁を作る。
ご飯を食べて、職場に向かう。
最寄駅まで歩き、電車に乗って職場への電車に乗る。

<P>
何故、人はごはんをよそうことが出来るのだろうか？
ごはんをよそうためにしゃもじを右手にとり、茶碗を左手に持つ。
炊飯器を空けて、ごはんをかき混ぜる。
かき混ぜたらごはんをしゃもじの上に乗せて、茶碗の上に持っていく。
しゃもじを回転させると、ごはんは茶碗に落ちる。

<P>
とても、とても難しいことをやっていると思わないだろうか？
不思議なことに、我々は「ごはんをよそう」と頭にあるだけ(と自覚している)だけなのに、何故かそのために必要な行動を列挙し、一つずつ実行していけるのである。

<P>
何故、我々は殆ど頭を(自覚的に)使わずにこのような計画を立てることが出来るのだろうか？何故ごはんをよそうためにお湯を沸かしたり、最寄り駅まで歩いたりする必要はないと分かるのだろうか？

<P>
それは我々が<B>直感</B> (ヒューリスティック)によって正しそうな行動を絞り込むことが出来るからである。

<P>
かつて人工知能の研究者らの一部は人間が直感と呼ぶものをコンピュータに実装することによってこれが実現できるのではないか、と考えた。まだ現在、「ごはんをよそう」という指令だけを受け、先にどういうことが起きるかを予想して、上記の行動を計画し、そして実際に実行するような人工知能は実装されていない。
このようなエージェントを実装する方法は様々あるかもしれないが、その一つに探索アルゴリズム(を一要素に含む技術)があるだろう。

<P>
<B>人工知能という言葉は、人間のように高度な先読みをし、高度な行動計画を行い実行の出来るシステムを作るという野望が言葉になったものである！</B>

<P>
<B>TODO: いい感じの絵</B>

<P>

<H1><A NAME="SECTION00210000000000000000"></A>
<A NAME="sec:why-search"></A><BR>
<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> 何故人工知能に探索が必要なのか
</H1>

<P>
グラフ探索アルゴリズムは人工知能に限らず情報科学に多岐に渡って有用な手法である。
本書では特に人工知能の要素技術としての問題を扱うために解説する。

<P>
人工知能とは何か、と考えることは本書の主眼ではない。
人工知能の教科書として有名なArtificial Intelligence: Modern Approach [<A
 HREF="textbook.html#russelln03">29</A>]では人工知能と呼ばれる研究は主に以下の４つの目標を目指していると説明している。

<P>

<OL>
<LI>Think Rationally
</LI>
<LI>Think Humanly
</LI>
<LI>Act Rationally
</LI>
<LI>Act Humanly
</LI>
</OL>

<P>
グラフ探索アルゴリズムは主にThink Rationallyを実現するための技術である<A NAME="tex2html1"
  HREF="#foot56"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN></SUP></A>。
探索によって<B>先読み</B> (lookahead) <A NAME="786"></A><A NAME="787"></A>をし、最も合理的な手を選ぶというのが目的である。

<P>
先読みをするという点が機械学習によるThink Rationallyと異なる点である。
機械学習は過去に学習した経験を元に合理的な行動を選ぶというアイディアである。
それに対して、探索は未来にどういう経験をするかを先読みして合理的な行動を選ぶ。

<P>
探索は特に学習データを得ることが難しいエージェントに用いられてきた。
例えば火星探査車などは宇宙のデータなどとても得られるものではないので、探索に基づくエージェントが用いられている。今後のNASAなどによる宇宙開発でも探索技術が重要であり続けるだろう。

<P>
もちろん両手法は組み合わせて用いることでより賢い行動が出来るようになる。
AlphaGoなどはまさに探索と機械学習を組み合わせたエージェントの強力さを体現しているといえるだろう。

<P>
このように、探索アルゴリズムは人工知能技術を理解する上で欠かせない分野の一つである。
特に最近大きなブレイクスルーのあった機械学習・深層学習とも強いシナジーを持っているため、これから大きな進展があると期待される分野の一つであると言えるだろう。

<P>

<H1><A NAME="SECTION00220000000000000000"></A>
<A NAME="sec:coverage"></A><BR>
<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> 本書の射程
</H1>

<P>
世界を正確に表現することは不可能である。
よって、殆どの問題はより解きやすい問題に<B>モデル化</B>され、モデル化された問題を解くことによって解きたい問題を解決するというのが情報科学である。

<P>
どのように世界をモデルするかは非常に難しい問題である。
モデルを簡単なものにすればするほど解きやすくなるが、簡単で正しいモデルをデザインする・自動生成することは非常に難しい。

<P>
本書が主に扱うモデルは<B>完全情報</B> (perfect information) <A NAME="789"></A><A NAME="790"></A>かつ<B>決定論的</B> (deterministic) <A NAME="792"></A><A NAME="793"></A>モデルである(<A HREF="#ch:state-space-problem">2</A>&nbsp;<A HREF="#ch:heuristic-serach-variants">7</A>章
)。

<P>
完全情報とは、エージェントが世界の状態を全て観察できるモデルである。神の目線に立っている。
これに対して<B>不完全情報</B> (partial infomation) <A NAME="795"></A><A NAME="796"></A>モデルではエージェントは世界の状態を知ることは出来ず、代わりに<B>観察</B> (observation) <A NAME="798"></A><A NAME="799"></A>をすることで世界の状態の一部を知ることが出来る。
実世界で動くロボットなどを考えると不完全情報モデルの方が現実的であるが、多くの問題が完全情報で十二分に表現することが出来る。

<P>
決定論的とはエージェントの行動によって世界の状態がどのように遷移するかが一意に(決定論的)に定まることである。
非決定論的モデルでは遷移が一意に定まらない。同じ状態から同じアクションを取ったとしても、世界がどのように変化するかは一意に定まらない。
非決定論的モデルにおける探索問題は<A HREF="#sec:stocastic"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>章で扱う。

<P>
本書が扱う完全情報決定論的モデルは最もシンプルなモデルである。
これを不完全情報、非決定論的モデルとすることでより元の問題も表現しやすくなることがあるが、一方でモデルのシンプルさを失うことになる。

<P>

<H1><A NAME="SECTION00300000000000000000"></A>
<A NAME="ch:state-space-problem"></A><BR>
<SPAN CLASS="arabic">2</SPAN>. 状態空間問題 (State-Space Problem)
</H1>

<P>
この章ではまず、<A HREF="#sec:state-space-problem">2.1</A>節ではグラフ探索手法が用いられる問題として状態空間問題を定義する。
次に<A HREF="#sec:search-problem">2.3</A>節で状態空間問題の例をいくつか紹介する。
経路探索問題や倉庫番問題など、応用がありつつ、かつ分かりやすい問題を選んだ。これらの問題はすべてヒューリスティック探索研究でベンチマークとして広く使われているものである。

<P>
<A HREF="#sec:state-space-problem">2.1</A>節における定式化は[<A
 HREF="textbook.html#russelln03">29</A>]、[<A
 HREF="textbook.html#pearl84">27</A>]、[<A
 HREF="textbook.html#edelkamp:2010:hst:1875144">8</A>]などを参考にしている。本文は入門の内容であるので、研究の詳細が知りたい方はこれらの教科書を読むべきである。

<P>

<H1><A NAME="SECTION00310000000000000000"></A>
<A NAME="sec:state-space-problem"></A><BR>
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> 状態空間問題 (State-Space Problem)
</H1>

<P>
<B>TODO: 状態空間問題の例示</B>
この本では主に初期状態とゴール条件が与えられたとき、ゴール条件を満たすための経路を返す問題を探索する手法を考える。
特に本書の主眼は<A HREF="#ch:state-space-problem">2</A>章から<A HREF="#ch:heuristic-serach-variants">7</A>章までで扱う<B>状態空間問題</B> (state-space problem) <A NAME="801"></A><A NAME="802"></A>である。状態空間問題<!-- MATH
 $P = (S, A, s, T)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="112" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img9.png"
 ALT="$ P = (S, A, s, T)$"></SPAN>は状態の集合<SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img10.png"
 ALT="$ S$"></SPAN>、初期状態<SPAN CLASS="MATH"><IMG
 WIDTH="42" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img11.png"
 ALT="$ s \in S$"></SPAN>、ゴール集合<SPAN CLASS="MATH"><IMG
 WIDTH="46" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img12.png"
 ALT="$ T \in S$"></SPAN>、アクション集合<!-- MATH
 $A = {a_1, ....,a_n}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="102" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img13.png"
 ALT="$ A = {a_1, ....,a_n}$"></SPAN>、<!-- MATH
 $a_i : S \rightarrow S$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="77" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img14.png"
 ALT="$ a_i : S \rightarrow S$"></SPAN>がある。アクションはある状態を次の状態に遷移させる関数である。
状態空間問題の解は初期状態からゴール状態へ遷移させるアクションの列を求めることである。

<P>
よって、状態空間問題はグラフにモデルすることで考えやすくなる。
状態空間問題を表す<B>状態空間グラフ</B> (state-space graph) <A NAME="804"></A><A NAME="805"></A>は以下のように定義される。

<P>
<P><DIV><B>Definition  <SPAN CLASS="arabic">1</SPAN></B> (状態空間グラフ、State-space graph)  &nbsp; 
<I>問題グラフ<!-- MATH
 $G = (V, E, s, T)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="113" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img15.png"
 ALT="$ G = (V, E, s, T)$"></SPAN>は状態空間問題<!-- MATH
 $P = (S, A, s, T)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="112" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img16.png"
 ALT="$ P = (S, A, s, T)$"></SPAN>に対して以下のように定義される。ノード集合 <SPAN CLASS="MATH"><IMG
 WIDTH="49" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img17.png"
 ALT="$ V = S$"></SPAN>、初期ノード<SPAN CLASS="MATH"><IMG
 WIDTH="42" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img18.png"
 ALT="$ s \in S$"></SPAN>、ゴールノード集合<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img19.png"
 ALT="$ T$"></SPAN>、エッジ集合<!-- MATH
 $E\subseteq V \times V$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="83" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img20.png"
 ALT="$ E\subseteq V \times V$"></SPAN>。エッジ<SPAN CLASS="MATH"><IMG
 WIDTH="61" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img21.png"
 ALT="$ u,v\in E$"></SPAN>は<SPAN CLASS="MATH"><IMG
 WIDTH="64" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img22.png"
 ALT="$ a(u) = v$"></SPAN>となる<SPAN CLASS="MATH"><IMG
 WIDTH="44" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img23.png"
 ALT="$ a\in A$"></SPAN>が存在する場合に存在し、そしてその場合にのみ存在する(iff)。</I></DIV><P></P>

<P>
状態空間問題の<B>解</B> (solution) <A NAME="807"></A><A NAME="808"></A>は以下の定義である。

<P>
<P><DIV><B>Definition  <SPAN CLASS="arabic">2</SPAN></B> (解、Solution)  &nbsp; 
<I>解<!-- MATH
 $\pi = (a_1,a_2...,a_k)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="122" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img24.png"
 ALT="$ \pi = (a_1,a_2...,a_k)$"></SPAN>はアクション<SPAN CLASS="MATH"><IMG
 WIDTH="49" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img25.png"
 ALT="$ a_i \in A$"></SPAN>の(順序付)配列であり、初期状態<SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img26.png"
 ALT="$ s$"></SPAN>からゴール状態<SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img27.png"
 ALT="$ t \in T$"></SPAN>へ遷移させる。すなわち、<SPAN CLASS="MATH"><IMG
 WIDTH="49" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img28.png"
 ALT="$ u_i \in S$"></SPAN>,<!-- MATH
 $i \in \{0,1,...,k\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="104" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img29.png"
 ALT="$ i \in \{0,1,...,k\}$"></SPAN>, <!-- MATH
 $u_0 = s, u_k = t$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="100" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$ u_0 = s, u_k = t$"></SPAN>が存在し、<!-- MATH
 $u_i = a_i(u_{i-1})$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="97" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$ u_i = a_i(u_{i-1})$"></SPAN>となる。</I></DIV><P></P>

<P>
どのような解を見つけたいかは問題に依存する。
多くの問題では<B>経路コスト</B> (path cost) <A NAME="810"></A><A NAME="811"></A>の合計を小さくすることを目的とする。

<P>
<P><DIV><B>Definition  <SPAN CLASS="arabic">3</SPAN></B> (コスト付き状態空間問題、Weighted state-space problem)  &nbsp; 
<I>コスト付き状態空間問題<!-- MATH
 $P = (S, A, s, T, w)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="130" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img32.png"
 ALT="$ P = (S, A, s, T, w)$"></SPAN>は状態空間問題の定義に加え、コスト関数<!-- MATH
 $w: A \rightarrow \mathbb{R}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="77" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img33.png"
 ALT="$ w: A \rightarrow \mathbb{R}$"></SPAN>がある。経路<!-- MATH
 $(a_1,...,a_k)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="76" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img34.png"
 ALT="$ (a_1,...,a_k)$"></SPAN>のコストは<!-- MATH
 $\sum^k_{i=1}w(a_i)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="83" HEIGHT="39" ALIGN="MIDDLE" BORDER="0"
 SRC="img35.png"
 ALT="$ \sum^k_{i=1}w(a_i)$"></SPAN>と定義される。ある解が可能なすべての解の中でコストが最小である場合、その解を最適解(optimal cost solution)であると言う。</I></DIV><P></P>

<P>
本書ではコスト付き状態空間問題をメインの問題として考える。
<P>
コストの定義されていない状態空間問題を特に区別して<B>ユニットコスト</B> (unit-cost) <A NAME="813"></A><A NAME="814"></A> 問題(ドメイン)と呼ぶ。
コスト付き状態空間問題は重み付き(コスト付き)グラフとしてモデルすることが出来る。すなわち、<!-- MATH
 $G = (V, E, s, T, w)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="131" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img36.png"
 ALT="$ G = (V, E, s, T, w)$"></SPAN>は状態空間グラフの定義に加え、エッジの重み<!-- MATH
 $w: E \leftarrow \mathbb{R}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="78" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="$ w: E \leftarrow \mathbb{R}$"></SPAN>を持つ。

<P>
<A HREF="#ch:blind-search">3</A>章で詳解するが、探索アルゴリズムは状態空間グラフのノード・エッジ全てを保持する必要はない。
全てのノード・エッジを保持した状態空間グラフを特に<B>明示的状態空間グラフ</B> (explicit state-space graph) <A NAME="816"></A><A NAME="817"></A>と呼ぶとする。このようなグラフは、例えば隣接行列を用いて表すことが出来る。隣接行列<SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img38.png"
 ALT="$ M$"></SPAN>は行と列の大きさが<SPAN CLASS="MATH"><IMG
 WIDTH="26" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img39.png"
 ALT="$ \vert V\vert$"></SPAN>である正方行列であり、エッジ<!-- MATH
 $(v_i, v_j)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="51" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img40.png"
 ALT="$ (v_i, v_j)$"></SPAN>が存在するならば<SPAN CLASS="MATH"><IMG
 WIDTH="64" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$ M_{i,j}=1$"></SPAN>、なければ<SPAN CLASS="MATH"><IMG
 WIDTH="64" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$ M_{i,j}=0$"></SPAN>とする行列である。
このような表現方法の問題点は行列の大きさが<SPAN CLASS="MATH"><IMG
 WIDTH="33" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img43.png"
 ALT="$ \vert V\vert^2$"></SPAN>であるため、大きな状態空間を保持することが出来ないことである。
例えば、<A HREF="#sec:search-problem">2.3</A>節で紹介する15-puzzleは状態の数が<SPAN CLASS="MATH"><IMG
 WIDTH="83" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img44.png"
 ALT="$ \vert V\vert=15!/2$"></SPAN>であるため、隣接行列を保持することは現在のコンピュータでは非常に困難である。

<P>
そこで、探索アルゴリズムは多くの場合初期ノードとノード展開関数による<B>非明示的状態空間グラフ</B> (implicit state-space graph) <A NAME="819"></A><A NAME="820"></A>で表せられる。

<P>
<P><DIV><B>Definition  <SPAN CLASS="arabic">4</SPAN></B> (非明示的状態空間グラフ、Implicit state-space graph)  &nbsp; 
<I>非明示的状態空間グラフは初期状態<SPAN CLASS="MATH"><IMG
 WIDTH="44" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img45.png"
 ALT="$ s \in V$"></SPAN>、ゴール条件Goal: <!-- MATH
 $V \rightarrow B = \{false, true\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="167" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img46.png"
 ALT="$ V \rightarrow B = \{false, true\}$"></SPAN>、ノード展開関数Expand: <!-- MATH
 $V \rightarrow 2^V$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="61" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img47.png"
 ALT="$ V \rightarrow 2^V$"></SPAN>によって与えられる。</I></DIV><P></P>

<P>
探索の開始時、エージェントは初期ノードのみを保持する。エージェントは保持しているノードに対してExpandを適用することによって、新しいノードとエッジをグラフに加える。これを求める解を見つけるまで繰り返す。
Expandはある状態からの次の状態の集合を返す関数である。Expand関数は明示的に与えられるのではなく、ルールによって与えられることが多い。例えば将棋であれば、将棋のルールによって定められる合法手によって得られる次の状態の集合がExpand関数によって得られる。
これによって、エージェントは解を見つけるまでのノード・エッジだけ保持して必要な解を見つけることが出来る。

<P>

<H1><A NAME="SECTION00320000000000000000"></A>
<A NAME="sec:search-problem-formulation"></A><BR>
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> 状態空間問題の定式化
</H1>

<P>
<BR><P></P>
<DIV ALIGN="CENTER">

<A NAME="tbl:search-problem-formulation"></A><A NAME="120"></A>
<TABLE CELLPADDING=3 BORDER="1">
<CAPTION><STRONG>Table 2.1:</STRONG>
状態空間問題における問題の定式化。もっとも情報が多く与えられる定式化がドメイン依存エージェントであり、ヒューリスティック関数なども与えられる。ドメイン非依存エージェントはPDDLなどのモデル言語で書かれた入力が与えられ、その情報から用いるヒューリスティック関数や効率化手法を自動的に選択する必要がある。ブラックボックスエージェントは事前に何も与えられない、最も挑戦的な定式化である。</CAPTION>
<TR><TD ALIGN="CENTER">問題</TD>
<TD ALIGN="CENTER">状態遷移関数</TD>
<TD ALIGN="CENTER">ヒューリスティック関数</TD>
<TD ALIGN="CENTER">効率化</TD>
</TR>
<TR><TD ALIGN="CENTER">ドメイン依存</TD>
<TD ALIGN="CENTER">Fully Available</TD>
<TD ALIGN="CENTER">hard-code</TD>
<TD ALIGN="CENTER">hard-code</TD>
</TR>
<TR><TD ALIGN="CENTER">ドメイン非依存 (PDDL)</TD>
<TD ALIGN="CENTER">Fully Available</TD>
<TD ALIGN="CENTER">自動生成する必要がある</TD>
<TD ALIGN="CENTER">ドメイン非依存の最適化・ポートフォリオ戦略</TD>
</TR>
<TR><TD ALIGN="CENTER">ブラックボックス</TD>
<TD ALIGN="CENTER">Unavailable (simulator)</TD>
<TD ALIGN="CENTER">Unavailable</TD>
<TD ALIGN="CENTER">非許容的なノード・エッジの枝刈り</TD>
</TR>
</TABLE>
</DIV><BR>

<P>

<H1><A NAME="SECTION00330000000000000000"></A>
<A NAME="sec:search-problem"></A><BR>
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> 状態空間問題の例
</H1>

<P>
状態空間問題の例をいくつか紹介する。
グリッド経路探索問題や倉庫番問題など、応用がありつつ、かつ分かりやすい問題を選んだ。これらの問題はすべてヒューリスティック探索研究でベンチマークとして広く使われているものである。
<P>

<H2><A NAME="SECTION00331000000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> グリッド経路探索 (Grid Path-finding)</A>
</H2><B>TODO: Grid Pathfinding: なんかいい感じの絵</B>

<DIV ALIGN="CENTER"><A NAME="fig:grid-pathfinding"></A><A NAME="132"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2.1:</STRONG>
グリッド経路探索問題</CAPTION>
<TR><TD><IMG
  WIDTH="600" HEIGHT="600" ALIGN="BOTTOM" BORDER="0"
 SRC="./grid-pathfinding.jpg"
 ALT="Image grid-pathfinding"></TD></TR>
</TABLE>
</DIV>

<P>
<B>グリッド経路探索問題</B> (grid path-finding problem) <A NAME="822"></A><A NAME="823"></A>は<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img48.png"
 ALT="$ k$"></SPAN>(多くの場合<SPAN CLASS="MATH"><IMG
 WIDTH="42" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img49.png"
 ALT="$ k=2$"></SPAN>)次元のグリッド上で初期配置からゴール位置までの経路を求める問題である[<A
 HREF="textbook.html#yap2002grid">33</A>]。グリッドには障害物がおかれ、通れない箇所がある。エージェントが移動できる方向は4方向(<!-- MATH
 $A= \{up, down, left, right\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="193" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img50.png"
 ALT="$ A= \{up, down, left, right\}$"></SPAN>)か8方向(4方向に加えて斜め移動)とする場合が多い。自由方向(Any Angle)の問題を扱う研究も存在する[<A
 HREF="textbook.html#nash2007theta">26</A>]。

<P>
Web上に簡単に試せるデモがあるので、参照されたい<A NAME="tex2html4"
  HREF="#foot718"><SUP><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN></SUP></A>。とてもよくできており、この文章で説明する様々なグラフ探索手法をグリッド経路探索に試すことが出来る。

<P>
グリッド経路探索はロボットのモーションプランニングやゲームAIなどで応用される[<A
 HREF="textbook.html#algfoor2015comprehensive">2</A>]。ストラテジーゲームなどでユニット（エージェント）を動かすために使われる。よく使われるベンチマーク問題集にもStarcraftのゲームのマップが含まれている[<A
 HREF="textbook.html#sturtevant2012benchmarks">32</A>].
またグリッドは様々な問題を経路探索に帰着して解くことができるという意味でも重要である。例えば多重整列問題 (Multiple Sequence Alignment)はグリッド経路探索に帰着して解くことが出来る(後述)。
ロボットのモーションプランニングも経路探索に帰着することが出来る。すなわち、<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img51.png"
 ALT="$ k$"></SPAN>個の関節の角度を変えて、現在状態からゴール状態へ遷移させたい。各関節の角度がグリッドの各次元に相当する。ロボットの物理的な構造により、関節のある角度の組み合わせは不可能である。不可能な組み合わせが、障害物の置かれたグリッドに相当する。よって、障害物を避けた経路というのが関節の動かし方ということになる。

<P>

<H2><A NAME="SECTION00332000000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> スライディングタイル (Sliding-tile Puzzle)</A>
</H2>

<P>
多くの一人ゲームはグラフ探索問題に帰着することが出来る。スライディングタイルはその例であり、ヒューリスティック探索研究においてメジャーなベンチマーク問題でもある (図<A HREF="#fig:15-puzzle">2.2</A>)。
<SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img52.png"
 ALT="$ 1$"></SPAN>から<SPAN CLASS="MATH"><IMG
 WIDTH="61" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img53.png"
 ALT="$ (n^2)-1$"></SPAN>までの数字が振られたタイルが<SPAN CLASS="MATH"><IMG
 WIDTH="43" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img54.png"
 ALT="$ n\times n$"></SPAN>の正方形に並べられている。正方形には一つだけ<I>ブランク</I>と呼ばれるタイルのない位置があり、四方に隣り合うタイルのいずれかをその位置に移動する(スライドする)ことが出来る。スライディングタイル問題は、与えられた初期状態からスライドを繰り返し、ゴール状態にたどり着く経路を求める問題である。

<P>

<DIV ALIGN="CENTER"><A NAME="fig:15-puzzle"></A><A NAME="147"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2.2:</STRONG>
15パズルのゴール状態の例</CAPTION>
<TR><TD><DIV ALIGN="CENTER">

</DIV><IMG
 WIDTH="222" HEIGHT="223" ALIGN="BOTTOM" BORDER="0"
 SRC="img55.png"
 ALT="\includegraphics[bb=0 0 372 373,width=0.4\textwidth]{figures/15-puzzle.eps}"></TD></TR>
</TABLE>
</DIV>

<P>
スライディングタイルの到達可能な状態の数は<!-- MATH
 $|V| = (n^2)!/2$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="96" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img56.png"
 ALT="$ \vert V\vert = (n^2)!/2$"></SPAN><A NAME="tex2html7"
  HREF="#foot719"><SUP><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN></SUP></A>であり、<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img57.png"
 ALT="$ n$"></SPAN>に対して指数的に増加する。
可能なアクションは<!-- MATH
 $A= \{up, down, left, right\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="193" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img58.png"
 ALT="$ A= \{up, down, left, right\}$"></SPAN>の４つであり、アクションにかかるコストはすべて同じとする。

<P>
後述するが、ヒューリスティック探索のためには状態からゴール状態までの距離(コスト)の下界（lower bound）が計算できると有用である。
スライディングタイルにおける下界の求め方として最もシンプルなものは<I>マンハッタン距離ヒューリスティック</I>である。マンハッタン距離ヒューリスティックは各タイルの現在状態の位置とゴール状態の位置のマンハッタン距離の総和を取る。可能なアクションはすべて一つしかタイルを動かさないので、一回のアクションでマンハッタン距離は最大で１しか縮まらない。よって、マンハッタン距離はゴールまでの距離の下界である。

<P>

<H2><A NAME="SECTION00333000000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> 多重整列問題 (Multiple Sequence Alignment)</A>
</H2>

<P>
生物学・進化学では遺伝子配列・アミノ酸配列の編集距離(edit distance)を比較することでニ個体がどれだけ親しいかを推定することが広く研究されている。
<B>多重整列問題</B> (Multiple Sequence Alignment) <A NAME="825"></A><A NAME="826"></A> (MSA)は複数の遺伝子・アミノ酸配列が与えられた時、それらの配列間の編集距離とその時出来上がった配列を求める問題である[<A
 HREF="textbook.html#edgar2006multiple">9</A>]。
２つの配列に対してそれぞれコストの定義された編集操作を繰り返し、同一の配列に並べ替える手続きをアライメントと呼ぶ。
２つの配列の編集距離は編集操作の合計コストの最小値である。
３つ以上の配列における距離の定義は様々考えられるが、ここでは全ての配列のペアの編集距離の総和を用いる。

<P>
MSAにおける可能な編集操作は置換と挿入である。置換は配列のある要素(DNAかアミノ酸)を別の要素に入れ替える操作であり、挿入は配列のある位置に要素を挿入する操作である。例えば(ABC, BCB, CB)の３つの配列のアライメントを考える。図<A HREF="#fig:msa-cost">2.3b</A>は置換と編集に対するコストの例である。-は欠損、すなわち挿入操作が行われたことを示す。アミノ酸配列における有名なコスト表としてPAM250[<A
 HREF="textbook.html#pearson1990">28</A>]があるが、ここでは簡単のため仮のコスト表を用いる。
図<A HREF="#fig:msa-solution">2.3a</A>はこのコスト表を用いたアライメントの例である。
このとき、例えば配列ABC-と-BCBの編集距離は(A,-)、 (B,B)、 (C,C)、 (-,B)のコストの総和であるので、図<A HREF="#fig:msa-cost">2.3b</A>を参照し、<!-- MATH
 $5+0+1+5=11$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="132" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img59.png"
 ALT="$ 5+0+1+5=11$"></SPAN>である。(-BCB, -CB)の距離は<SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img60.png"
 ALT="$ 6$"></SPAN>, (-CB, ABC-)の距離は<SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img61.png"
 ALT="$ 16$"></SPAN>であるので、３配列の編集距離は<!-- MATH
 $11+6+16=33$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="120" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img62.png"
 ALT="$ 11+6+16=33$"></SPAN>である。

<P>
<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img63.png"
 ALT="$ n$"></SPAN>配列のMSAは<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img64.png"
 ALT="$ n$"></SPAN>次元のグリッドの経路探索問題に帰着することが出来る[<A
 HREF="textbook.html#korf:2000">22</A>]。
図<A HREF="#fig:msa-to-grid">2.3c</A>は(ABC)と(BCB)の２つの配列による問題を表す。
状態<SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img65.png"
 ALT="$ s$"></SPAN>は２つの変数によって表現される:<!-- MATH
 $(x_0, x_1)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="56" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img66.png"
 ALT="$ (x_0, x_1)$"></SPAN>。<SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img67.png"
 ALT="$ x_0$"></SPAN>は配列0のどの位置までアライメントを完了したかを表す変数であり、配列<SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img68.png"
 ALT="$ i$"></SPAN>の長さを<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img69.png"
 ALT="$ l_i$"></SPAN>とすると定義域は<!-- MATH
 $0 \leq x_0 \leq l_0$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="83" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img70.png"
 ALT="$ 0 \leq x_0 \leq l_0$"></SPAN>である。
全てのアライメントが完了した状態<!-- MATH
 $s=(l_0, l_1)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="76" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img71.png"
 ALT="$ s=(l_0, l_1)$"></SPAN>がゴール状態である。
可能なアクションは<!-- MATH
 $a=(b_0, b_1), (b_i=0, 1)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="157" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img72.png"
 ALT="$ a=(b_0, b_1), (b_i=0, 1)$"></SPAN>の形を取り、これは配列<SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img73.png"
 ALT="$ i$"></SPAN>に対して欠損を挿入する場合に<SPAN CLASS="MATH"><IMG
 WIDTH="45" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img74.png"
 ALT="$ b_i=0$"></SPAN>となる。
状態<SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img75.png"
 ALT="$ s$"></SPAN>に対してアクション<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img76.png"
 ALT="$ a$"></SPAN>を適用した後の状態<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img77.png"
 ALT="$ s'$"></SPAN>は<!-- MATH
 $s'=(x_0+b_0, x_1+b_1)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="156" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img78.png"
 ALT="$ s'=(x_0+b_0, x_1+b_1)$"></SPAN>となる。例えば図<A HREF="#fig:msa-to-grid">2.3c</A>は初期状態<SPAN CLASS="MATH"><IMG
 WIDTH="68" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img79.png"
 ALT="$ s=(0,0)$"></SPAN>に対して<SPAN CLASS="MATH"><IMG
 WIDTH="69" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img80.png"
 ALT="$ a=(1,0)$"></SPAN>を適用している。これは(A), (-)までアライメントを進めた状態に対応する。次に<SPAN CLASS="MATH"><IMG
 WIDTH="69" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img81.png"
 ALT="$ a=(1,1)$"></SPAN>が適用され、アライメントは(A,B), (-,B)という状態に至る。

<P>
このようにして、MSAはグリッド経路探索問題に帰着し、グラフ探索アルゴリズムよって解くことが出来る。
状態空間問題として考えた場合にMSAの難しさはアクションのコストが幅広いことにある。また、可能なアクションの数も配列の数<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img82.png"
 ALT="$ n$"></SPAN>に対して<SPAN CLASS="MATH"><IMG
 WIDTH="48" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img83.png"
 ALT="$ 2^n-1$"></SPAN>と大きい。

<P>
MSAは生物学研究に役立つというモチベーションから非常に熱心に研究されており、様々な定式化による解法が知られている[<A
 HREF="textbook.html#edgar2006multiple">9</A>]。

<P>

<DIV ALIGN="CENTER">

<P><A NAME="fig:msa-solution"></A><A NAME="fig:msa-cost"></A><A NAME="fig:msa-to-grid"></A><A NAME="fig:msa-to-grid-align"></A></P><IMG
 WIDTH="317" HEIGHT="236" BORDER="0"
 SRC="img84.png"
 ALT="\begin{figure}\centering
\subfloat[MSAの解の例]{
\begin{tabular}{ccccc}
A &amp;...
...&amp; A &amp; B &amp; C &amp; - \\ \hline
&amp; - &amp; B &amp; C &amp; B \\ \hline
\end{tabular}}
\end{figure}">
</DIV>

<P>

<H2><A NAME="SECTION00334000000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> 倉庫番 (Sokoban)</A>
</H2>
倉庫番(Sokoban)は日本発のパズルゲームであり、倉庫の荷物を押していくことで指定された位置に置くというゲームである。現在でも様々なゲームでゲーム内ミニゲームとして親しまれている。
プレイヤーは「荷物の後ろに回って押す」ことしか出来ず、引っ張ったり、横から動かしたりすることが出来ない。また、荷物の上を通ることも出来ない。
PSPACE-completeであることが知られている[<A
 HREF="textbook.html#culberson1997sokoban">6</A>]。

<P>

<DIV ALIGN="CENTER"><A NAME="fig:sokoban"></A><A NAME="188"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2.3:</STRONG>
Sokoban: 画像はwikipediaより。</CAPTION>
<TR><TD><DIV ALIGN="CENTER">

</DIV><IMG
 WIDTH="222" HEIGHT="248" ALIGN="BOTTOM" BORDER="0"
 SRC="img85.png"
 ALT="\includegraphics[bb=0 0 213 238,width=0.4\textwidth]{figures/sokoban.eps}"></TD></TR>
</TABLE>
</DIV>

<P>
状態の表現方法は２通りあり、一つはグリッドの各位置に何が置いてあるかを変数とする方法である。もうひとつはプレイヤー、各荷物の位置に対してそれぞれ変数を割り当てる方法である。
可能なアクションは<!-- MATH
 $\{move-up,move-left,move-down,move-right,push-up,push-left,push-down,push-right\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="743" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img86.png"
 ALT="$ \{move-up,move-left,move-down,move-right,push-up,push-left,push-down,push-right\}$"></SPAN>の８通りである。<SPAN CLASS="MATH"><IMG
 WIDTH="69" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img87.png"
 ALT="$ move-*$"></SPAN>はプレイヤーが動くアクションに対応し、コストは0である。<SPAN CLASS="MATH"><IMG
 WIDTH="65" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img88.png"
 ALT="$ push-*$"></SPAN>は荷物を押すアクションであり、正のアクションコストが割当てられている。よって、倉庫番はなるべく荷物を押す回数を少なくして荷物を目的の位置に動かすことが目的となる。

<P>
グラフ探索問題として倉庫番を考えるときに重要であるのは、倉庫番は<I>不可逆な</I>アクション(irreversible)があることである。
グリッド経路探索やスライディングタイルは<I>可逆な</I> (reversible)問題である。
全てのアクション<SPAN CLASS="MATH"><IMG
 WIDTH="44" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img89.png"
 ALT="$ a \in A$"></SPAN>に対して<!-- MATH
 $a^{-1} \in A$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="61" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img90.png"
 ALT="$ a^{-1} \in A$"></SPAN>が存在し、<!-- MATH
 $a(a^{-1}(s)) = s$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="99" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img91.png"
 ALT="$ a(a^{-1}(s)) = s$"></SPAN>かつ<!-- MATH
 $a^{-1}(a(s)) = s$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="99" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img92.png"
 ALT="$ a^{-1}(a(s)) = s$"></SPAN>となる場合、問題は可逆であると言う。
可逆な問題は対応するアクションのコストが同じであれば無向グラフとしてモデルすることも出来、初期状態から到達できる状態は、すべて初期状態に戻ることが出来る。
一方、不可逆な問題ではこれが保証されず、詰み(trap)状態に陥る可能性がある。

<P>
倉庫番では荷物を押すことは出来ても引っ張ることが出来ないため、不可逆な問題である。例えば、荷物を部屋の隅に置いてしまうと戻すことが出来ないため、詰み状態に陥る可能性がある問題である。
このような性質を持つ問題では特にグラフ探索による先読みが効果的である。

<P>
もうひとつ重要な問題はゼロコストアクションの存在である。
倉庫番のアクションのうち<!-- MATH
 $\{move-up,move-left,move-down,move-right\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="387" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img93.png"
 ALT="$ \{move-up,move-left,move-down,move-right\}$"></SPAN>はコストゼロ(<SPAN CLASS="MATH"><IMG
 WIDTH="65" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img94.png"
 ALT="$ w(e)=0$"></SPAN>)のアクションである。ヘタなアルゴリズムを実行すると無限に無駄なアクションを繰り返し続けるということもありうるだろう。

<P>

<H2><A NAME="SECTION00335000000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> 巡回セールスパーソン問題 (Traveling Salesperson Problem, TSP)</A>
</H2>

<P>
セールスパーソンはいくつかの都市に回って営業を行わなければならない。都市間の距離(=コスト)は事前に与えられている。
TSPは全ての都市を最短距離で回ってはじめの都市に戻る経路を求める、という問題である[<A
 HREF="textbook.html#applegate2006traveling">3</A>]。

<P>

<DIV ALIGN="CENTER"><A NAME="fig:sokoban"></A><A NAME="200"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2.4:</STRONG>
巡回セールスパーソン問題: 画像はwikipediaより。</CAPTION>
<TR><TD><DIV ALIGN="CENTER">

</DIV><IMG
 WIDTH="222" HEIGHT="238" ALIGN="BOTTOM" BORDER="0"
 SRC="img95.png"
 ALT="\includegraphics[bb=0 0 328 352,width=0.4\textwidth]{figures/tsp.eps}"></TD></TR>
</TABLE>
</DIV>
<B>TODO: travelling salesman絵</B>

<P>
<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img96.png"
 ALT="$ n$"></SPAN>個の都市があるとすると(最適・非最適含む)解の数は<SPAN CLASS="MATH"><IMG
 WIDTH="74" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img97.png"
 ALT="$ (n-1)!/2$"></SPAN>個である。
可能なアクションは「都市<!-- MATH
 $i \in \{1..n\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="71" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img98.png"
 ALT="$ i \in \{1..n\}$"></SPAN>を訪れる」であり、一度訪れた都市には行けない。
TSPのゴール条件はすべての都市を訪れることである。よって、<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img99.png"
 ALT="$ n$"></SPAN>回どれかアクションを実行すれば、とりあえず解を得ることが出来る。一方、最適解を得る問題はNP完全であることが知られている。

<P>
TSPの解の下界としては<I>最小全域木</I> (minimum spanning tree)のコストがよく用いられる[<A
 HREF="textbook.html#held1970traveling">12</A>]。
グラフの<I>全域木</I> (spanning tree)は全てのノードを含むループを含まない部分グラフである。
最小全域木は全域木のうち最もエッジコストの総和が小さいものである。
未訪問の都市によるグラフの最小全域木はTSPの下界となることが知られている。

<P>
TSPはヒューリスティック探索に限らず、様々なアプローチで研究されている問題ドメインである[<A
 HREF="textbook.html#applegate2006traveling">3</A>]。TSPについて特に詳しく知りたい方はそちらの教科書を参照されたい。

<P>

<H1><A NAME="SECTION00340000000000000000"></A>
<A NAME="sec:difficulity"></A><BR>
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> 問題の難しさ
</H1>
状態数あるいは状態空間の大きさ
<B>分枝度</B> (branching factor) <A NAME="828"></A><A NAME="829"></A>
Trap vs. reversible

<P>

<H1><A NAME="SECTION00400000000000000000"></A>
<A NAME="ch:blind-search"></A><BR>
<SPAN CLASS="arabic">3</SPAN>. 情報なし探索 (Blind Search)
</H1>

<P>
<A HREF="#ch:introduction">1</A>章では様々な状態空間問題を紹介したが、それぞれの問題の解法はどれも沢山研究されている。
一つの指針としては、ある問題に特化した解法を研究することでその問題をより高速に解くというモチベーションがある。
これは例えばMSAのように重要なアプリケーションがある問題の場合に特に熱心に研究されることが多い。
一方、なるべく広い範囲の問題に対して適用可能な手法を研究するというモチベーションもある。
特に人工知能の文脈において、なるべく問題の知識を必要とせず、最小限の仮定のみを必要とする解法が求められる。
<P>
<A HREF="#ch:introduction">1</A>章で紹介した状態空間問題を広く扱うことの出来る手法としてグラフ探索アルゴリズムがある。
本章では最もシンプルな問題（ドメイン）の知識を利用しない探索を紹介する。
情報なし探索 (Blind Search)は状態空間グラフのみに注目し、背景にある問題に関する知識を一切使わないアルゴリズムである。
このような探索を設計に重要なことは<B>1. 重複検知を行うか 2. ノードの展開順序</B>の二点である。
重複検出は訪問済みのノードを保存しておくことで同じノードを繰り返し探索することを防ぐ手法である。対価としては、メモリの消費量が非常に大きくなることにある。
ノードの展開順序とは、例えば幅優先探索・深さ優先探索などのバリエーションを指す。
効率的な展開順序は問題によって大きく異なり、問題を選べばこれらの手法によって十分に効率的な探索を行うことが出来る。
これらの探索手法は競技プログラミングでもよく解法として使われる[<A
 HREF="textbook.html#skiena2006programming">30</A>]。また、いわゆるコーディング面接でもグラフ探索アルゴリズムは頻出である[<A
 HREF="textbook.html#mcdowell2011cracking">24</A>]。
<P>
<BR><P></P>
<DIV ALIGN="CENTER">

<A NAME="tbl:tree-vs-graph-search"></A><A NAME="220"></A>
<TABLE CELLPADDING=3 BORDER="1">
<CAPTION><STRONG>Table 3.1:</STRONG>
木探索とグラフ探索</CAPTION>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">重複検出</TD>
<TD ALIGN="CENTER">保存するノード</TD>
<TD ALIGN="CENTER">完全性</TD>
</TR>
<TR><TD ALIGN="CENTER">木探索</TD>
<TD ALIGN="CENTER">重複検出しない</TD>
<TD ALIGN="CENTER">オープンリストのみ</TD>
<TD ALIGN="CENTER">ループを含むグラフである場合停止性を満たさない</TD>
</TR>
<TR><TD ALIGN="CENTER">グラフ探索</TD>
<TD ALIGN="CENTER">重複検出する</TD>
<TD ALIGN="CENTER">オープンリストとクローズドリスト</TD>
<TD ALIGN="CENTER">(状態空間が有限ならば)完全</TD>
</TR>
</TABLE>
</DIV><BR>

<P>
<BR><P></P>
<DIV ALIGN="CENTER">
<A NAME="tbl:basic-priority"></A><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">展開順序</TD>
<TD ALIGN="CENTER">プライオリティ</TD>
<TD ALIGN="CENTER">性質</TD>
</TR>
<TR><TD ALIGN="CENTER">幅優先</TD>
<TD ALIGN="CENTER"><!-- MATH
 $\arg \min_n d(n)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="97" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img100.png"
 ALT="$ \arg \min_n d(n)$"></SPAN></TD>
<TD ALIGN="CENTER">ユニットコストドメインだと最初に発見した解が最適解である</TD>
</TR>
<TR><TD ALIGN="CENTER">深さ優先</TD>
<TD ALIGN="CENTER"><!-- MATH
 $\arg \max_n d(n)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="100" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img101.png"
 ALT="$ \arg \max_n d(n)$"></SPAN></TD>
<TD ALIGN="CENTER"><B>TODO</B></TD>
</TR>
<TR><TD ALIGN="CENTER">最良優先</TD>
<TD ALIGN="CENTER"><!-- MATH
 $\arg \min_n g(n)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="97" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img102.png"
 ALT="$ \arg \min_n g(n)$"></SPAN></TD>
<TD ALIGN="CENTER">非負コストドメインで最適解が得られる</TD>
</TR>
</TABLE>
</DIV><BR>

<P>

<H1><A NAME="SECTION00410000000000000000"></A>
<A NAME="sec:tree-search-algorithm"></A><BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> 木探索アルゴリズム (Tree Search Algorithm)
</H1>
木探索アルゴリズムはグラフ探索アルゴリズムの基礎となるフレームワークであり、本文で紹介する手法のほとんどがこのフレームワークを基礎としているといえる。

<P>
アルゴリズム<A HREF="#alg:implicit-tree-search">1</A>は木探索の疑似コードである。

<P>
<BR>
<A NAME="alg:implicit-tree-search"></A><IMG
 WIDTH="556" HEIGHT="279" ALIGN="BOTTOM" BORDER="0"
 SRC="img103.png"
 ALT="\begin{algorithm}
% latex2html id marker 235\caption{Implicit Tree Search}
\I...
...t(v)$\;
$parent(v) \leftarrow u$\;
}
}
\Return $\emptyset$\;
\end{algorithm}">
<BR>

<P>
<BR>
<A NAME="alg:expand"></A><IMG
 WIDTH="556" HEIGHT="185" ALIGN="BOTTOM" BORDER="0"
 SRC="img104.png"
 ALT="\begin{algorithm}
% latex2html id marker 246\caption{Expand}
\Input{Parent no...
...tarrow d(s) + w(s, s')$\;
$S = S \cup {s'}$\;
}
\Return $S$\;
\end{algorithm}">
<BR>

<P>
以下、(k)と書いて疑似コードのk行目を指すことにする。
木探索はオープンリスト<A NAME="tex2html11"
  HREF="#foot726"><SUP><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN></SUP></A>と呼ばれるノードの集合をPriority queueに保持する。探索の開始時には、初期状態のみがオープンリストに入っている(1)。
木探索は、このオープンリストから一つノード<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img105.png"
 ALT="$ u$"></SPAN>を選び(3)、ゴール条件を満たしているかを確認する(4)。満たしていれば初期状態から<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img106.png"
 ALT="$ u$"></SPAN>への経路を返す。満たしていなければ、そのノードを展開する(6-)。展開とは、そのノードの子ノードを列挙し、オープンリストに入れる(8)ことを指す。

<P>
アルゴリズム<A HREF="#alg:expand">2</A>は展開関数の動作を表している。
初期状態からノード<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img107.png"
 ALT="$ n$"></SPAN>への既知の最小経路コストを<SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img108.png"
 ALT="$ g$"></SPAN>値と呼ぶ。
状態を更新すると同時に<SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img109.png"
 ALT="$ g$"></SPAN>値を更新する。これによって解を発見した時に解ノードの<SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img110.png"
 ALT="$ g$"></SPAN>値が解のコストとなる。
なお、状態<SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img111.png"
 ALT="$ s$"></SPAN>に対して適用可能なアクションの集合<SPAN CLASS="MATH"><IMG
 WIDTH="36" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img112.png"
 ALT="$ A(s)$"></SPAN>は与えられていると仮定する。

<P>
探索の進行によってエージェントが保持する情報は変化していく。ここでは探索がどのように進行するかを記述するため、以下の３つの言葉を定義する：

<P>

<OL>
<LI>展開済みノード: <SPAN CLASS="MATH"><IMG
 WIDTH="60" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img113.png"
 ALT="$ Expand$"></SPAN>によって子ノードが参照されたノードを指す。<SPAN CLASS="MATH"><IMG
 WIDTH="42" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img114.png"
 ALT="$ Open$"></SPAN>からは省かれる。
</LI>
<LI>生成済みノード: <!-- MATH
 $Open.insert$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="89" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img115.png"
 ALT="$ Open.insert$"></SPAN>によってOpenに一度でも入れられたノードを指す。
</LI>
<LI>未生成ノード: まだ生成されていないノード。よって、非明示的グラフに保持されていない。

<P>
</LI>
</OL>

<P>
非明示的グラフ木探索の強みは、生成済みノードのうち展開済みではないもののみを<SPAN CLASS="MATH"><IMG
 WIDTH="42" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img116.png"
 ALT="$ Open$"></SPAN>に保持すればよいことにある。未生成ノード、展開済みノードはメモリ上に保持する必要がない。
一方、これの問題は、一度展開したノードが再び現れた場合、<B>再展開 (reexpansion)</B>をすることになる。よって、グラフがより木から遠いほど(複数の経路で到達可能なノードがあるほど)同じノードを何度も再展開することになり、効率が悪くなってしまう。もっと言えば、木探索アルゴリズムは状態数が有限であっても停止しない場合がある。
これらが問題になるような問題ドメインである場合は後述する重複検出を使うグラフ探索<A HREF="#sec:graph-search-algorithm">3.4</A>を使うと良いだろう。

<P>
<B>紛らわしいが、木探索アルゴリズムはグラフを探索するアルゴリズムである。</B>
グラフ探索アルゴリズムのうち、後述する重複検出を行わない手法を木探索アルゴリズムと呼ぶ。

<P>

<H1><A NAME="SECTION00420000000000000000"></A>
<A NAME="sec:breadth-first-search"></A><BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> 幅優先探索 (Breadth-First Search)
</H1>

<P>
木探索のパフォーマンスにおいて重要になるのは<B>どのようにして次に展開するノードを選択するか</B>にある(<!-- MATH
 $Open.pop()$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="82" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img117.png"
 ALT="$ Open.pop()$"></SPAN>)。
ヒューリスティック探索の研究の非常に大きな部分はここに費やされているといえる。
シンプルかつ強力なノード選択方法はFirst-in-first-out (FIFO)である。あるいは幅優先探索と呼ぶ。

<P>
幅優先探索の手順は非常に単純であり、FIFOの順に<SPAN CLASS="MATH"><IMG
 WIDTH="42" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img118.png"
 ALT="$ Open$"></SPAN>から取り出せばいいだけである。
これをもう少し大きな視点で、<I>どのようなノードを優先して探索しているのか</I>を考えてみたい。
初期状態から現在状態にたどり着くまでの経路の長さをノードの<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img119.png"
 ALT="$ d$"></SPAN>値と定義する。
すると、幅優先探索の<!-- MATH
 $Open.pop()$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="82" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img120.png"
 ALT="$ Open.pop()$"></SPAN>はアルゴリズム<A HREF="#alg:brfs-open">3</A>のように書くことが出来る。
ユニットコスト問題である場合、<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img121.png"
 ALT="$ d$"></SPAN>値は<SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img122.png"
 ALT="$ g$"></SPAN>値と一致する。

<P>
幅優先探索のメリットは初めに発見した解が最短経路長であることである。
問題がユニットコストドメインであれば、最短経路が最小コスト経路であるので、最適解が得られる。

<P>
<BR>
<A NAME="alg:brfs-open"></A><IMG
 WIDTH="556" HEIGHT="69" ALIGN="BOTTOM" BORDER="0"
 SRC="img123.png"
 ALT="\begin{algorithm}
% latex2html id marker 266\caption{Breadth-First Search: $Open.pop()$}
\Output{Node $n$}
\Return $\arg \min_n d(n)$
\end{algorithm}">
<BR>

<P>

<H1><A NAME="SECTION00430000000000000000"></A>
<A NAME="sec:depth-first-search"></A><BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> 深さ優先探索 (Depth-First Search)
</H1>

<P>
幅優先探索が幅を優先するのに対して深さ優先探索はもっとも深いノードを優先して探索する。

<P>
深さ優先探索は解がある一定の深さにあることが既知である場合に有効である。
例えばTSPは全ての街を回ったときのみが解であるので、街の数が<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img124.png"
 ALT="$ n$"></SPAN>であれば全ての解の経路長が<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img125.png"
 ALT="$ n$"></SPAN>である。
このような問題を幅優先探索で解こうとすると、解は最も深いところにしかないので、最後の最後まで解が一つも得られないということになる。一方、深さ優先探索なら<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img126.png"
 ALT="$ n$"></SPAN>回目の展開で一つ目の解を見つけることが出来る。

<P>
良い解、最適解を見つけたい場合でも深さ優先探索が有用である場合がある。
早めに一つ解が見つけられると、その解よりも質が悪い解にしかつながらないノードを枝刈り(pruning)することが出来る。詳しくは<A HREF="#sec:pruning"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>章で解説する。

<P>
<BR>
<A NAME="alg:dfs-open"></A><IMG
 WIDTH="556" HEIGHT="69" ALIGN="BOTTOM" BORDER="0"
 SRC="img127.png"
 ALT="\begin{algorithm}
% latex2html id marker 274\caption{Depth-First Search: $Open.pop()$}
\Output{Node $n$}
\Return $\arg \max_n g(n)$
\end{algorithm}">
<BR>

<P>

<H1><A NAME="SECTION00440000000000000000"></A>
<A NAME="sec:graph-search-algorithm"></A><BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> グラフ探索アルゴリズム (Graph Search Algorithm)
</H1>

<P>
明示的グラフのあるノードが初期状態から複数の経路でたどり着ける場合、同じ状態を表すノードが木探索による非明示的グラフに複数現れるということが生じる。このようなノードを<B>重複</B> (duplicate) <A NAME="832"></A><A NAME="833"></A>と呼ぶ。ノードの重複は計算資源を消費してしまうので、効率的な<B>重複検出</B> (duplicate detection) <A NAME="835"></A><A NAME="836"></A>の方法は重要な研究分野である。

<P>
<B>本書ではノードの重複検出を行う探索アルゴリズムを狭義にグラフ探索アルゴリズムと呼び、重複検出を行わない探索を木探索と区別する。</B>

<P>
<BR>
<A NAME="alg:implicit-graph-search"></A><IMG
 WIDTH="556" HEIGHT="298" ALIGN="BOTTOM" BORDER="0"
 SRC="img128.png"
 ALT="\begin{algorithm}
% latex2html id marker 286\caption{Implicit Graph Search}
\...
... \in Succ(u)$} {
$Improve(u, v)$\;
}
}
\Return $\emptyset$\;
\end{algorithm}">
<BR>

<P>
<BR>
<A NAME="alg:improve"></A><IMG
 WIDTH="556" HEIGHT="126" ALIGN="BOTTOM" BORDER="0"
 SRC="img129.png"
 ALT="\begin{algorithm}
% latex2html id marker 297\caption{$Improve(u,v)$}
\Input{N...
...\cup Open$} {
$Open.insert(v)$\;
$parent(v) \leftarrow u$\;
}
\end{algorithm}">
<BR>

<P>

<H1><A NAME="SECTION00450000000000000000"></A>
<A NAME="sec:dijkstra"></A><BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> ダイクストラ法  (Dijkstra Algorithm)
</H1>

<P>
<B>ダイクストラ法</B> (Dijkstra's Algorithm) <A NAME="838"></A><A NAME="839"></A>は非負コストグラフにおいて最短経路を返すアルゴリズムである[<A
 HREF="textbook.html#dijkstra1959note">7</A>]。
ダイクストラ法は<SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img130.png"
 ALT="$ g$"></SPAN>値が最も小さいノードを優先して展開するグラフ探索アルゴリズムである。
<P>
<BR>
<A NAME="alg:dfs-open"></A><IMG
 WIDTH="556" HEIGHT="69" ALIGN="BOTTOM" BORDER="0"
 SRC="img131.png"
 ALT="\begin{algorithm}
% latex2html id marker 310\caption{Best-First Search: $Open.pop()$}
\Output{Node $u$}
\Return $\arg \max_n g(n)$
\end{algorithm}">
<BR>

<P>
グラフ理論の教科書などでも登場する情報科学全体に多岐に渡り重要とされるアルゴリズムである。
例えばネットワークルーティングにおけるlink state algorithmなどにDijkstraが使われる[<A
 HREF="textbook.html#mcquillan1980new">25</A>]。

<P>
ユニットコストドメインでは<!-- MATH
 $\forall n (g(n) = d(n))$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="116" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img132.png"
 ALT="$ \forall n (g(n) = d(n))$"></SPAN>であるため、幅優先探索と同じ動作をする。
フィボナッチヒープを用いてオープンリストを実装したダイクストラ法は<!-- MATH
 $O(|E| + |V|log|V|)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="134" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img133.png"
 ALT="$ O(\vert E\vert + \vert V\vert log\vert V\vert)$"></SPAN>時間でであることが知られている[]。実用するにあたっては、後述するヒューリスティック関数が得られない(難しい)問題においてはとりあえずダイクストラ法を試してみることは有効である。

<P>

<H1><A NAME="SECTION00500000000000000000"></A>
<A NAME="ch:heuristic-search"></A><BR>
<SPAN CLASS="arabic">4</SPAN>. ヒューリスティック探索 (Heuristic Search)
</H1>

<P>
<A HREF="#ch:blind-search">3</A>章では問題の知識を利用しないグラフ探索手法について解説した。
本章では問題の知識を利用することでより効率的なグラフ探索を行う手法、特にヒューリスティック探索について解説する。

<P>

<H1><A NAME="SECTION00510000000000000000"></A>
<A NAME="sec:heursitic"></A><BR>
<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ヒューリスティックとは？
</H1>

<P>
経路探索問題を幅優先探索で解くことを考えよう。
図<A HREF="#fig:grid"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>の初期状態からゴールへの最短経路の長さはXである。このとき、幅優先探索は図<A HREF="#fig:grid-brfs"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>の領域を探索する。
しかし人間が経路探索を行うときにこんなに広い領域を探索しないだろう。なぜか。
それは人間が問題の特徴を利用して、このノードを探索したほうがよいだろう、という推論を働かせているからである。
問題の特徴を利用してノードの<B>有望さ</B>をヒューリスティック関数として定量化し、ヒューリスティック関数を利用した探索アルゴリズムをヒューリスティック探索と呼ぶ。
ヒューリスティック関数は人間が自分の知識を利用してコーディングする場合もあるが、特にプランニング問題などでは自動的にヒューリスティックを生成する手法も広く使われている。

<P>
<B>TODO: ヒューリスティックとは: grid, grid-brfsの図を挿入</B>

<P>

<H1><A NAME="SECTION00520000000000000000"></A>
<A NAME="sec:heuristic-function"></A><BR>
<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ヒューリスティック関数
</H1>
ヒューリスティック関数はある状態からゴールまでの最短距離の見積もりである。

<P>
<P><DIV><B>Definition  <SPAN CLASS="arabic">5</SPAN></B> (ヒューリスティック関数)  &nbsp; 
<I>ヒューリスティック関数<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img134.png"
 ALT="$ h$"></SPAN>はノードの評価関数である。<!-- MATH
 $h: V \rightarrow \mathbb{R}_{\geq 0}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="93" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img135.png"
 ALT="$ h: V \rightarrow \mathbb{R}_{\geq 0}$"></SPAN></I></DIV><P></P>

<P>
ヒューリスティック値が低いノードほどゴールに近いと推測できるので、探索ではヒューリスティック値が小さいノードを優先して展開する。
ヒューリスティック関数の値をそのノードの<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img136.png"
 ALT="$ h$"></SPAN>値と呼ぶことが多い。

<P>
ヒューリスティック関数の望ましい性質として、まず正確である方が望ましい。すなわち、<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img137.png"
 ALT="$ h$"></SPAN>値が実際のゴールまでの最短距離に近いほど、有用な情報であると言える。
もう一つ望ましい性質は<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img138.png"
 ALT="$ h$"></SPAN>値が最適解コストの下界である場合である。
<A HREF="#sec:astar-search">4.3</A>章で解説するが、<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img139.png"
 ALT="$ h$"></SPAN>値が最短距離の下界である場合、それを用いた効率的な探索アルゴリズム(A*探索、重み付きA*探索)において解コストに理論的保証が得られることが広く知られている。
<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img140.png"
 ALT="$ h$"></SPAN>値が常に最適解コストの下界であるヒューリスティック関数を許容的なヒューリスティックと呼ぶ。

<P>
<P><DIV><B>Definition  <SPAN CLASS="arabic">6</SPAN></B> (許容的なヒューリスティック)  &nbsp; 
<I>ヒューリスティック関数<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img141.png"
 ALT="$ h$"></SPAN>は最適解のコストの下界である場合、許容的である。すなわち、全てのノード<SPAN CLASS="MATH"><IMG
 WIDTH="45" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img142.png"
 ALT="$ u \in V$"></SPAN>に対して<!-- MATH
 $h(u) \leq h^*(u)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="94" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img143.png"
 ALT="$ h(u) \leq h^*(u)$"></SPAN>が成り立つ。</I></DIV><P></P>

<P>
ただし、<SPAN CLASS="MATH"><IMG
 WIDTH="42" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img144.png"
 ALT="$ h^*(u)$"></SPAN>はノード<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img145.png"
 ALT="$ u$"></SPAN>からゴールノード集合<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img146.png"
 ALT="$ T$"></SPAN>のいずれかへたどり着くための最短経路である。

<P>
一般に、許容的なヒューリスティックを得る方法としては、元問題の<B>緩和問題</B>を解き、その最適解コストをヒューリスティック値とすることである。ある問題の緩和問題とは、解集合に元の問題の解を含む問題を指す。要するに元の問題より簡単な問題である<A NAME="tex2html12"
  HREF="#foot336"><SUP><SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN></SUP></A>。

<P>
もう一つ重要な性質は無矛盾性である。

<P>
<P><DIV><B>Definition  <SPAN CLASS="arabic">7</SPAN></B> (無矛盾なヒューリスティック)  &nbsp; 
<I>ヒューリスティック関数<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img147.png"
 ALT="$ h$"></SPAN>は全てのエッジ<!-- MATH
 $e = (u, v) \in E$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="102" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img148.png"
 ALT="$ e = (u, v) \in E$"></SPAN>に対して<!-- MATH
 $h(u) \leq h(v) + w(u,v)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="154" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img149.png"
 ALT="$ h(u) \leq h(v) + w(u,v)$"></SPAN>が成り立つ場合、無矛盾である。</I></DIV><P></P>

<P>
無矛盾性は特に<A HREF="#sec:astar-search">4.3</A>章で後述するA*探索において探索の効率性に重要な性質である。

<P>
また、無矛盾なヒューリスティックのうちゴールノードの<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img150.png"
 ALT="$ h$"></SPAN>値が0となるヒューリスティックは許容的である。

<P>
<P><DIV><B>Theorem  <SPAN CLASS="arabic">1</SPAN></B> &nbsp; 
<I>ゴールノード<SPAN CLASS="MATH"><IMG
 WIDTH="45" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img151.png"
 ALT="$ n \in T$"></SPAN>に対して<SPAN CLASS="MATH"><IMG
 WIDTH="64" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img152.png"
 ALT="$ h(n) = 0$"></SPAN>となる無矛盾なヒューリスティックは許容的なヒューリスティックである。</I></DIV><P></P>

<P>
<P></P>
<DIV><I>Proof</I>.
あるノード<SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img154.png"
 ALT="$ n_0$"></SPAN>からゴールノード<SPAN CLASS="MATH"><IMG
 WIDTH="53" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img155.png"
 ALT="$ n_k \in T$"></SPAN>への最短経路(ノードの列)を<!-- MATH
 $(n_0, n_1,...)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="77" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img156.png"
 ALT="$ (n_0, n_1,...)$"></SPAN>と置く。無矛盾なヒューリスティック<SPAN CLASS="MATH"><IMG
 WIDTH="35" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img157.png"
 ALT="$ h(n)$"></SPAN>は
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay"><TABLE CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="RIGHT"><SPAN CLASS="MATH"><IMG
 WIDTH="42" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img158.png"
 ALT="$\displaystyle h(n_0)$"></SPAN></TD>
<TD NOWRAP ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="143" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img159.png"
 ALT="$\displaystyle \leq h(n_1) + w(n_0, n_1)$"></SPAN></TD>
<TD NOWRAP CLASS="eqno" WIDTH="10" ALIGN="RIGHT">
(<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN>)</TD></TR>
<TR VALIGN="MIDDLE">
<TD>&nbsp;</TD>
<TD NOWRAP ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="227" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img160.png"
 ALT="$\displaystyle \leq h(n_2) + w(n_0, n_1) + w(n_1, n_2)$"></SPAN></TD>
<TD NOWRAP CLASS="eqno" WIDTH="10" ALIGN="RIGHT">
(<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN>)</TD></TR>
<TR VALIGN="MIDDLE">
<TD>&nbsp;</TD>
<TD NOWRAP ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img161.png"
 ALT="$\displaystyle ...$"></SPAN></TD>
<TD NOWRAP CLASS="eqno" WIDTH="10" ALIGN="RIGHT">
(<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN>)</TD></TR>
<TR VALIGN="MIDDLE">
<TD>&nbsp;</TD>
<TD NOWRAP ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="220" HEIGHT="52" ALIGN="MIDDLE" BORDER="0"
 SRC="img162.png"
 ALT="$\displaystyle \leq h(n_k) + \sum_{i=0..k-1}(w(n_i,n_{i+1}))$"></SPAN></TD>
<TD NOWRAP CLASS="eqno" WIDTH="10" ALIGN="RIGHT">
(<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN>)</TD></TR>
<TR VALIGN="MIDDLE">
<TD>&nbsp;</TD>
<TD NOWRAP ALIGN="LEFT"><SPAN CLASS="MATH"><IMG
 WIDTH="67" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img163.png"
 ALT="$\displaystyle = h^*(n_0)$"></SPAN></TD>
<TD NOWRAP CLASS="eqno" WIDTH="10" ALIGN="RIGHT">
(<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>
よって<!-- MATH
 $h(n_0) \leq h^*(n_0)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="109" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img164.png"
 ALT="$ h(n_0) \leq h^*(n_0)$"></SPAN>より許容的である。

<P>
 <IMG
 WIDTH="17" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img153.png"
 ALT="$ \qedsymbol$">
</DIV><P></P>

<P>

<H1><A NAME="SECTION00530000000000000000"></A>
<A NAME="sec:astar-search"></A><BR>
<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> A*探索
</H1>

<P>
<B>TODO: ダイクストラ法の問題点を図示</B>
ダイクストラ法は初期状態からそのノードまでのコストである<SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img165.png"
 ALT="$ g$"></SPAN>値が最小のノードを展開していく。これは間違った方針ではないだろうが、理想的にはゴール状態に向かっていくノードを展開していきたい。図<A HREF="#fig:dijkstra-grid"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>はダイクストラ法による状態空間の探索を図示したものである。ダイクストラ法はゴールがどこにあるかということを無視して探索を進めているため、図のように探索空間が広がっていく。
<P>
<B>A*探索</B> (A* search) <A NAME="841"></A><A NAME="842"></A>はゴールまでの距離を見積もる<B>ヒューリスティック関数</B> (heuristic function) <A NAME="844"></A><A NAME="845"></A>を用いることで図<A HREF="#fig:astar-grid"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>のようにゴールに向かって探索していくことを目指した手法である。

<P>
A*探索はヒューリスティック探索の代名詞である、最も広く知られている
手法である[<A
 HREF="textbook.html#fikes:71">11</A>]。
A*探索は以下の<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img166.png"
 ALT="$ f$"></SPAN>値が最小となるノードを優先したグラフ探索アルゴリズムである。

<P>
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay"><!-- MATH
 \begin{equation}
f(n) = g(n) + h(n)
\end{equation}
 -->
<TABLE CLASS="equation" CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="137" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img167.png"
 ALT="$\displaystyle f(n) = g(n) + h(n)$"></SPAN></TD>
<TD NOWRAP CLASS="eqno" WIDTH="10" ALIGN="RIGHT">
(<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>

<P>
ノード<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img168.png"
 ALT="$ n$"></SPAN>の<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img169.png"
 ALT="$ f$"></SPAN>値は、初期状態から<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img170.png"
 ALT="$ n$"></SPAN>を通過してゴール状態に辿り着くためのコストの見積もりである。<SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img171.png"
 ALT="$ g$"></SPAN>値は初期状態からノード<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img172.png"
 ALT="$ n$"></SPAN>までの既知の最短経路コストである。一方<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img173.png"
 ALT="$ h$"></SPAN>値はヒューリスティック関数による<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img174.png"
 ALT="$ n$"></SPAN>からゴール状態までの最短経路の見積もりである。
A*探索は非明示的グラフ探索アルゴリズム(アルゴリズム<A HREF="#alg:implicit-graph-search">5</A>)の一つであり、<!-- MATH
 $Open.pop()$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="82" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img175.png"
 ALT="$ Open.pop()$"></SPAN>を<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img176.png"
 ALT="$ f$"></SPAN>値最小ノードを返すようにしただけである <A HREF="#alg:astar-search">8</A>。

<P>
<BR>
<A NAME="alg:astar-search"></A><IMG
 WIDTH="556" HEIGHT="69" ALIGN="BOTTOM" BORDER="0"
 SRC="img177.png"
 ALT="\begin{algorithm}
% latex2html id marker 362\caption{A* Search: $Open.pop()$}
\Output{Node $n$}
\Return $\arg \min_n g(n) + h(n)$
\end{algorithm}">
<BR>

<P>
ダイクストラ法(<A HREF="#sec:dijkstra">3.5</A>章)と比較すると、A*探索はゴール状態までのコストの見積もりを考慮して次に展開するノードを決めている。

<P>
図<A HREF="#fig:astar-grid"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>は<B>マンハッタン距離ヒューリスティック</B> (Manhattan distance heuristic) <A NAME="847"></A><A NAME="848"></A>によるA*探索である。

<P>
A*に用いるヒューリスティック関数に求められる要件とは何であるか。
一つは正確であるほど良い。
もう一つはヒューリスティック関数がゴールまでのコストの下界であると実用的・理論的に良い性質があることが知られている。

<P>
<P><DIV><B>Theorem  <SPAN CLASS="arabic">2</SPAN></B> &nbsp; 
<I>ヒューリスティックが許容的である時、A*は最適解を返す。</I></DIV><P></P>

<P></P>
<DIV><I>Proof</I>.
<B>TODO: 最適性の証明</B>許容的なヒューリスティックh(n)はnからゴールへの経路の下界である。よって、ゴール状態のh値は0である。つまりゴール状態のf値はg値と同じである。この解のg(n')値をf*と置こう(解のコストに相当)。
A*のノードの展開順に従うと、f*のノードを展開する前に全てのf&lt;f*のノードが展開される。
これらのノードがいずれもゴール状態でなければ、g(n)&lt;=f(n)より、g(n)&lt;f*となるゴール状態がない。すなわち、f*が最適解のコストとなり、n'がその時のゴール状態である。

<P>
 <IMG
 WIDTH="17" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img178.png"
 ALT="$ \qedsymbol$">
</DIV><P></P>

<P>
無矛盾なヒューリスティックである場合、全てのノードnは展開時までにg(n)がnに辿り着くための最短経路コストの値になる。

<P>
<P><DIV><B>Theorem  <SPAN CLASS="arabic">3</SPAN></B> &nbsp; 
<I>無矛盾なヒューリスティックを用いたA*探索はノードの再展開が生じない。</I></DIV><P></P>

<P>

<H2><A NAME="SECTION00531000000000000000"></A>
<A NAME="sec:weighted-astar-search"></A><BR>
<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> 重み付きA*探索
</H2>

<P>
許容的なヒューリスティックを用いたA*探索は最適解が得られるが、必ずしも最適解がほしいわけではない場合もある。解のクオリティよりもとにかく解が何か欲しい、という場合もある。
重み付きA*探索(weighted A*, wA*)は解のクオリティが落ちる代わりにより素早く買いにたどり着くための手法である。
wA*は重み付き<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img179.png"
 ALT="$ f$"></SPAN>値、<SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img180.png"
 ALT="$ f_w$"></SPAN>が最小のノードを優先して探索する。

<P>
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay"><!-- MATH
 \begin{equation}
f_w(n) = g(n) + w h(n)
\end{equation}
 -->
<TABLE CLASS="equation" CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="158" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img181.png"
 ALT="$\displaystyle f_w(n) = g(n) + w h(n)$"></SPAN></TD>
<TD NOWRAP CLASS="eqno" WIDTH="10" ALIGN="RIGHT">
(<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>

<P>
<BR>
<A NAME="alg:wastar-open"></A><IMG
 WIDTH="556" HEIGHT="69" ALIGN="BOTTOM" BORDER="0"
 SRC="img182.png"
 ALT="\begin{algorithm}
% latex2html id marker 382\caption{w A*: $Open.pop()$}
\Output{Node $u$}
\Return $\arg \min_n f_w(n)$
\end{algorithm}">
<BR>

<P>
<P><DIV><B>Theorem  <SPAN CLASS="arabic">4</SPAN></B> &nbsp; 
<I>許容的なヒューリスティックを用いた重み付きA*探索は最適解のコスト<SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img183.png"
 ALT="$ f^*$"></SPAN>に対して、発見される解のコストが<SPAN CLASS="MATH"><IMG
 WIDTH="33" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img184.png"
 ALT="$ w f^*$"></SPAN>以下であることを保証する。</I></DIV><P></P>

<B>TODO: wA*: 解コストの上界の証明</B>

<P>
wA*の利点はそこそこの計算時間で解のクオリティに保証がついた解を見つけることが出来ることにある。
wA*の解は最適解のコストの上界になるので、A*探索の枝刈りに用いることが出来る。
A*探索を実行する前にwA*を走らせ、解の上界を得、A*探索実行時にその値を超す<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img185.png"
 ALT="$ f$"></SPAN>値を持ったノードを

<P>

<H1><A NAME="SECTION00540000000000000000"></A>
<A NAME="sec:greedy-best-first-search"></A><BR>
<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> 貪欲最良優先探索 (Greedy Best-First Search)
</H1>

<P>
解のクオリティに保証がない。

<P>
<BR>
<A NAME="alg:gfs-open"></A><IMG
 WIDTH="556" HEIGHT="69" ALIGN="BOTTOM" BORDER="0"
 SRC="img186.png"
 ALT="\begin{algorithm}
% latex2html id marker 392\caption{Greedy Best-First Search: $Open.pop()$}
\Output{Node $u$}
\Return $\arg \min_n h(n)$
\end{algorithm}">
<BR>

<P>

<H1><A NAME="SECTION00550000000000000000"></A>
<A NAME="sec:heuristic-example"></A><BR>
<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ドメイン固有のヒューリスティック関数
</H1>

<P>
<A HREF="#sec:heuristic-function">4.2</A>章にあるように、なるべく正確であり、許容的、無矛盾なヒューリスティックが望ましい。
一般に、許容的なヒューリスティックを得る方法としては、元問題の<B>緩和問題</B>を解き、その最適解コストをヒューリスティック値とすることである。ある問題の緩和問題とは、解集合に元の問題の解を含む問題を指す。要するに元の問題より簡単な問題である<A NAME="tex2html13"
  HREF="#foot401"><SUP><SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN></SUP></A>。
グラフ探索アルゴリズムにおいて緩和問題を作る方法は様々あるが、一つはグラフのエッジを増やすことで緩和が出来る。グラフのエッジを増やすには、問題の可能なアクションを増やすなどの方法がある。

<P>

<H2><A NAME="SECTION00551000000000000000">
<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> グリッド経路探索：マンハッタン距離</A>
</H2>

<P>
４方向グリッド経路探索問題の元問題は障害物のあるグリッドに移動することは出来ない。グリッド経路探索で有効なヒューリスティックの一つはマンハッタン距離ヒューリスティックである。これは現在位置とゴール位置のマンハッタン距離を<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img187.png"
 ALT="$ h$"></SPAN>値とする。マンハッタン距離の意味としては、障害物を無視した最短経路の距離であるので、グラフのエッジを増やした緩和問題である。
このように、問題の性質を理解していれば許容的なヒューリスティック関数を設計することが出来る。
８方向グリッドにおいても斜め方向を加えた距離を考えることで許容的なヒューリスティックとすることが出来る。Any angleグリッドならば直線距離が許容的なヒューリスティックである。

<P>

<H2><A NAME="SECTION00552000000000000000">
<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> スライディングタイル:マンハッタン距離</A>
</H2>
スライディングタイルにおけるマンハッタン距離ヒューリスティックは各タイルの現在の位置とゴール状態の位置のマンハッタン距離の総和を<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img188.png"
 ALT="$ h$"></SPAN>値とする。
スライディングタイル問題において一度に動かせるタイルは１つであり、その距離は１つである。
そのため、マンハッタン距離ヒューリスティックは許容的なヒューリスティックである。
<P>

<H2><A NAME="SECTION00553000000000000000">
<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> 巡回セールスパーソン問題：最小全域木</A>
</H2>
TSPの解の下界としては<I>最小全域木</I> (minimum spanning tree)のコストがよく用いられる。
グラフの<I>全域木</I> (spanning tree)は全てのノードを含むループを含まない部分グラフである。
最小全域木は全域木のうち最もエッジコストの総和が小さいものである。
未訪問の都市によるグラフの最小全域木はTSPの下界となることが知られている。

<P>

<H1><A NAME="SECTION00600000000000000000"></A><A NAME="ch:classical-planning"></A><BR>
<SPAN CLASS="arabic">5</SPAN>. 自動行動計画問題 (Automated Planning Problem)
</H1>
この章では自動行動計画問題について説明する。
古典的プランニング問題はエージェントの自動行動計画を行うための問題の一つであり、状態空間問題の一つである [<A
 HREF="textbook.html#fikes:71">11</A>]。

<P>
ロジスティック[<A
 HREF="textbook.html#helmert2010scanalyzer">13</A>,<A
 HREF="textbook.html#sousa2013toward">31</A>]、セルアセンブリ[<A
 HREF="textbook.html#asai2014fully">4</A>]、遺伝子距離計算[<A
 HREF="textbook.html#erdem2005genome">10</A>]、ビデオゲーム[<A
 HREF="textbook.html#lipovetzky2015a">23</A>]など、様々な応用問題を含むフレームワークである。

<P>
環境が決定的であり、完全情報を仮定する。
これらの仮定を緩和した問題（確率的モデルや不完全情報モデル）もグラフ探索によって解かれることが多いが、本文の範囲外とする。詳細はAIの教科書を参照されたい[<A
 HREF="textbook.html#russelln03">29</A>]。

<P>
なお、プランニング問題はA*などの状態空間探索アルゴリズム以外にも、SATやCSPなどの制約充足問題に変換して解く方法もあるがこれも本書の範囲外とする[<A
 HREF="textbook.html#kautz:92">19</A>]。

<P>

<H1><A NAME="SECTION00610000000000000000"></A>
<A NAME="sec:planning-definition"></A><BR>
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> 定義
</H1>

<P>
古典的プランニングは述語論理によって世界が記述される[<A
 HREF="textbook.html#fikes:71">11</A>]。
Proposition <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img189.png"
 ALT="$ AP$"></SPAN>は世界の状態において何が真・偽であるかを記述する。
世界の状態はエージェントがアクションを行うことによって遷移し、遷移後の状態は遷移前の状態と異なるpropositionが真・偽でありうる。
古典的プランニングの目的は与えられた初期状態からゴール条件を満たすまでのアクションの列を求めることにある。
以下、定義は[<A
 HREF="textbook.html#edelkamp:2010:hst:1875144">8</A>]に従う。

<P>
<P><DIV><B>Definition  <SPAN CLASS="arabic">8</SPAN></B> (古典的プランニング問題、Classical Planning Problem)  &nbsp; 
<I>古典的プランニング問題は有限状態空間問題<!-- MATH
 $P = (S,A,s_0,T)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="119" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img190.png"
 ALT="$ P = (S,A,s_0,T)$"></SPAN>の一つである。
<!-- MATH
 $S \subseteq 2^{AP}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="64" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img191.png"
 ALT="$ S \subseteq 2^{AP}$"></SPAN>は状態の集合であり、<SPAN CLASS="MATH"><IMG
 WIDTH="49" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img192.png"
 ALT="$ s_0 \in S$"></SPAN>は初期状態、<!-- MATH
 $T \subseteq S$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="48" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img193.png"
 ALT="$ T \subseteq S$"></SPAN>はゴール状態の集合、<!-- MATH
 $A: S \rightarrow S$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="75" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img194.png"
 ALT="$ A: S \rightarrow S$"></SPAN>は可能なアクションの集合である。</I></DIV><P></P>

<P>
古典的プランニング問題の最も基本となるSTRIPSモデル[<A
 HREF="textbook.html#fikes:71">11</A>]の場合、ゴールはpropositionのリストで表せられる<!-- MATH
 $Goal \subseteq AP$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="83" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img195.png"
 ALT="$ Goal \subseteq AP$"></SPAN>。ゴール状態の集合<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img196.png"
 ALT="$ T$"></SPAN>は<!-- MATH
 $p \in Goal$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="65" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img197.png"
 ALT="$ p \in Goal$"></SPAN>となるすべての<SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img198.png"
 ALT="$ p$"></SPAN>が真である状態の集合である。
アクション<SPAN CLASS="MATH"><IMG
 WIDTH="44" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img199.png"
 ALT="$ a \in A$"></SPAN>は条件<SPAN CLASS="MATH"><IMG
 WIDTH="48" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img200.png"
 ALT="$ pre(a)$"></SPAN>、効果(<SPAN CLASS="MATH"><IMG
 WIDTH="50" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img201.png"
 ALT="$ add(a)$"></SPAN>, <SPAN CLASS="MATH"><IMG
 WIDTH="46" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img202.png"
 ALT="$ del(a)$"></SPAN>)で表せられる。条件<!-- MATH
 $pre(a) \subseteq AP$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="94" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img203.png"
 ALT="$ pre(a) \subseteq AP$"></SPAN>はアクション<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img204.png"
 ALT="$ a$"></SPAN>を実行するために状態が満たすべきpropositionの集合である。効果<SPAN CLASS="MATH"><IMG
 WIDTH="50" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img205.png"
 ALT="$ add(a)$"></SPAN>はアクション<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img206.png"
 ALT="$ a$"></SPAN>を適用後に真になるpropositionの集合であり、<SPAN CLASS="MATH"><IMG
 WIDTH="46" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img207.png"
 ALT="$ del(a)$"></SPAN>は偽になる集合である。
従って、アクション<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img208.png"
 ALT="$ a$"></SPAN>を状態<SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img209.png"
 ALT="$ s$"></SPAN>に適用後の状態<!-- MATH
 $s' = suc(s,a)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="96" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img210.png"
 ALT="$ s' = suc(s,a)$"></SPAN>は
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay"><!-- MATH
 \begin{equation}
s' = (s \cup add(a)) \setminus del(a)
\end{equation}
 -->
<TABLE CLASS="equation" CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="177" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img211.png"
 ALT="$\displaystyle s' = (s \cup add(a)) \setminus del(a)$"></SPAN></TD>
<TD NOWRAP CLASS="eqno" WIDTH="10" ALIGN="RIGHT">
(<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>
である。
このようにして、古典的プランニング問題は後述のグラフ探索問題に帰着することが出来る。

<P>
As such, a classical planning problem can be solved by an A* search (<!-- MATH
 $G(V', E', w'), s_0', T'$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="139" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img212.png"
 ALT="$ G(V', E', w'), s_0', T'$"></SPAN>); <SPAN CLASS="MATH"><IMG
 WIDTH="53" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img213.png"
 ALT="$ V' = S$"></SPAN>, <!-- MATH
 $e(v_i, v_j) \in E'$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="95" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img214.png"
 ALT="$ e(v_i, v_j) \in E'$"></SPAN> exists if there exists <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img215.png"
 ALT="$ a$"></SPAN> such that <!-- MATH
 $v_j = succ(v_i, a)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="111" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img216.png"
 ALT="$ v_j = succ(v_i, a)$"></SPAN>, <!-- MATH
 $s_0' = s_0$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="54" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img217.png"
 ALT="$ s_0' = s_0$"></SPAN>, <SPAN CLASS="MATH"><IMG
 WIDTH="53" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img218.png"
 ALT="$ T' = T$"></SPAN>.

<P>

<H1><A NAME="SECTION00620000000000000000"></A>
<A NAME="sec:pddl"></A><BR>
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> Planning Domain Definition Language
</H1>

<P>
Planning Domain Definition Language (PDDL) [<A
 HREF="textbook.html#aeronautiques1998pddl">1</A>]はプランニング問題を記述されるために用いられる言語の一つである。PDDLはdomainファイルとinstanceファイルの２つのファイルによって一つの入力となる。domainファイルはpredicateとアクションが定義され、instanceファイルは初期状態、ゴール状態とオブジェクトが定義される。
図<A HREF="#fig:pddl-domain">5.1</A>はblocks-worldのdomainファイルである。
図<A HREF="#fig:pddl-instance">5.2</A>はblocks-worldのinstanceファイルである。

<P>

<DIV ALIGN="CENTER"><A NAME="fig:pddl-domain"></A><A NAME="435"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5.1:</STRONG>
blocks-worldのdomainファイル</CAPTION>
<TR><TD><IMG
 WIDTH="644" HEIGHT="908" BORDER="0"
 SRC="img219.png"
 ALT="\begin{figure}\lstset{language=pddl}
\begin{lstlisting}
;;;;;;;;;;;;;;;;;;;;;;;;...
...(clear ?x))
(not (handempty))
(not (on ?x ?y)))))
\end{lstlisting}\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>

<DIV ALIGN="CENTER"><A NAME="fig:pddl-instance"></A><A NAME="442"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5.2:</STRONG>
blocks-worldのinstanceファイル</CAPTION>
<TR><TD><IMG
 WIDTH="664" HEIGHT="149" BORDER="0"
 SRC="img220.png"
 ALT="\begin{figure}\lstset{language=pddl}
\begin{lstlisting}
(define (problem BLOCKS-...
...Y))
(:goal (AND (ON D C) (ON C B) (ON B A)))
)
\par
\end{lstlisting}\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>

<H1><A NAME="SECTION00630000000000000000"></A>
<A NAME="sec:classical-planning-example"></A><BR>
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> 古典的プランニング問題の例
</H1>ソリティア
エレベーター
空港最適化
グリッド経路探索: ２章で紹介した問題がPDDLで表せられることを示すため
グリッパー
サテライト

<P>

<H2><A NAME="SECTION00631000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> ブロックスワールド (blocks world)</A>
</H2>
説明用候補

<H2><A NAME="SECTION00632000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> ロジスティック (logistics)</A>
</H2>
説明用候補

<H2><A NAME="SECTION00633000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> プリンタースケジュリング (printer scheduling)</A>
</H2>
説明用候補

<P>

<H2><A NAME="SECTION00634000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> セルアセンブリ (cell assembly)</A>
</H2>
コラム候補

<H2><A NAME="SECTION00635000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> クエリ最適化 (query optimization)</A>
</H2>
コラム候補

<H2><A NAME="SECTION00636000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> 宇宙探査車 (rovers)</A>
</H2>
コラム候補

<H2><A NAME="SECTION00637000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> サイバーセキュリティ (cyber security)</A>
</H2>
コラム候補

<H2><A NAME="SECTION00638000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> ゲノムリアレンジメント (genome rearrangement)</A>
</H2>
コラム候補

<H2><A NAME="SECTION00639000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN> グリッドコンピューティング</A>
</H2>
コラム候補

<P>

<H1><A NAME="SECTION00640000000000000000"></A>
<A NAME="sec:automated-heuristic"></A><BR>
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> ヒューリスティック関数の自動生成
</H1>

<P>
ドメイン非依存エージェントはヒューリスティック関数を自動生成しなければならない。

<P>

<H2><A NAME="SECTION00641000000000000000">
<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ゴールカウントヒューリスティック</A>
</H2>

<P>
多くの問題ではゴールはいくつかの条件を満たした状態の集合として与えられる。
ゴールカウントヒューリスティックは満たしていないゴール条件の数をヒューリスティック値とする関数である。
例えばスライディングタイルのゴール条件は全てのタイルが所定の位置にあることである。
なので所定の位置にないタイルの数を<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img221.png"
 ALT="$ h$"></SPAN>値とすることが出来る。

<P>
ゴールカウントヒューリスティックは許容的であるとは限らない。コスト１のアクションが２つのゴールを同時に満たすかもしれないからだ。スライディングタイルであれば１つのアクションで動かせるタイルの数は１つなので、許容的である。

<P>

<H1><A NAME="SECTION00700000000000000000"></A>
<A NAME="ch:search-performance"></A><BR>
<SPAN CLASS="arabic">6</SPAN>. 実験評価
</H1>
ヒューリスティック探索ではオープンリストとクローズドリストの２つのデータ構造を保持する。
これらのデータ構造をどのように実装するかは探索の効率に大きな影響を与える。
オープンリストはPriority queueであり、必要な操作はpopとpushである。
クローズドリストはinsertとfindである。

<P>

<H1><A NAME="SECTION00710000000000000000"></A>
<A NAME="sec:open-list"></A><BR>
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> オープンリスト
</H1>Priority queueの実装方法は様々ある。
まず、<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img222.png"
 ALT="$ f$"></SPAN>値の定義域が実数か、整数かは重要である。
実数である場合は二分木のような一般的なPriority queueを使うことが多い。
整数である場合は<I>bucket</I>実装をすることが出来る。

<P>
次に、<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img223.png"
 ALT="$ f$"></SPAN>値が同じノードが複数ある場合のタイブレーキング (tiebreaking)もパフォーマンスに影響を与える。
<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img224.png"
 ALT="$ h$"></SPAN>値が最も小さいノードを優先することが多い。
FIFO, LIFOのどちらが良いかという問題もある。

<P>

<H2><A NAME="SECTION00711000000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> データ構造</A>
</H2>
<BR><P></P>
<DIV ALIGN="CENTER">

<A NAME="tbl:open-list-data-structure"></A><A NAME="466"></A>
<TABLE CELLPADDING=3>
<CAPTION><STRONG>Table 6.1:</STRONG>
オープンリストのデータ構造の比較</CAPTION>
<TR><TD ALIGN="CENTER">pests are used to
support farmer decisions. Such maps are costly to obtain since they require 
	実装</TD>
<TD ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="28" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img225.png"
 ALT="$ pop$"></SPAN>計算量</TD>
<TD ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="38" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img226.png"
 ALT="$ push$"></SPAN>計算量</TD>
</TR>
<TR><TD ALIGN="CENTER">二分木</TD>
<TD ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="72" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img227.png"
 ALT="$ O(log(n))$"></SPAN></TD>
<TD ALIGN="CENTER">XX</TD>
</TR>
<TR><TD ALIGN="CENTER">bucket</TD>
<TD ALIGN="CENTER">XXX</TD>
<TD ALIGN="CENTER">XXX</TD>
</TR>
</TABLE>
</DIV><BR>

<P>

<H2><A NAME="SECTION00712000000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> タイブレーキング</A>
</H2>
bucket open list
h tiebreaking
FIFO, LIFO tiebreaking

<P>

<H1><A NAME="SECTION00720000000000000000"></A>
<A NAME="sec:closed-list"></A><BR>
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> クローズドリスト
</H1><B>TODO: closed list</B>
クローズドリストはハッシュテーブル
incremental hashing
perfect hashing
universal hashing

<P>

<H2><A NAME="SECTION00721000000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Delayed Duplicate Detection</A>
</H2>
重複検出のタイミングは２通りある。

<P>

<H1><A NAME="SECTION00800000000000000000"></A>
<A NAME="ch:heuristic-serach-variants"></A><BR>
<SPAN CLASS="arabic">7</SPAN>. ヒューリスティック探索の派生
</H1>
<P>
<BR><P></P>
<DIV ALIGN="CENTER">

<A NAME="tbl:search-variants"></A><A NAME="480"></A>
<TABLE CELLPADDING=3>
<CAPTION><STRONG>Table 7.1:</STRONG>
派生アルゴリズムの比較。</CAPTION>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">空間計算量</TD>
<TD ALIGN="CENTER">時間計算量</TD>
<TD ALIGN="CENTER">有効な場面</TD>
</TR>
<TR><TD ALIGN="CENTER">反復深化A*</TD>
<TD ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img228.png"
 ALT="$ O(n)$"></SPAN></TD>
<TD ALIGN="CENTER">展開ノード数が大きくなる。キャッシュ効率が良くなる場合がある</TD>
<TD ALIGN="CENTER">キャッシュ効率が良いとA*よりも高速な場合がある</TD>
</TR>
<TR><TD ALIGN="CENTER">両方向探索</TD>
<TD ALIGN="CENTER">A*よりも小さい</TD>
<TD ALIGN="CENTER">重複検出の効率による</TD>
<TD ALIGN="CENTER">ヒューリスティック関数の性能が低い場合に有効</TD>
</TR>
<TR><TD ALIGN="CENTER">External Search</TD>
<TD ALIGN="CENTER">外部記憶を用いる</TD>
<TD ALIGN="CENTER">I/Oを必要とするため遅い</TD>
<TD ALIGN="CENTER">探索空間がメモリに乗り切らない場合</TD>
</TR>
<TR><TD ALIGN="CENTER">Symbolic Search</TD>
<TD ALIGN="CENTER">BDDによって効率的になる</TD>
<TD ALIGN="CENTER">複数のノードを同時に展開できる</TD>
<TD ALIGN="CENTER"><B>TODO</B></TD>
</TR>
<TR><TD ALIGN="CENTER">並列探索</TD>
<TD ALIGN="CENTER">使用する計算ノードのメモリの総計が使える</TD>
<TD ALIGN="CENTER">線形スピードアップならコアの数だけ高速化</TD>
<TD ALIGN="CENTER">問題が難しい</TD>
</TR>
</TABLE>
</DIV><BR>

<P>
A*探索などのヒューリスティック探索は時間と空間の両方がボトルネックとなりうる。
すなわち、A*はノードを一つずつ展開していかなければならないので、その数だけExpandを実行しなければならない。また、A*は重複検出のために展開済みノードをすべてクローズドリストに保存する。なので、必要な空間も展開ノード数に応じて増えていく。

<P>
残念ながら、ほぼ正しいコストを返すヒューリスティック関数を使っても、A*が展開するノードの数は指数的に増加することが知られている[<A
 HREF="textbook.html#helmert:08">14</A>]。

<P>
そのため、ヒューリスティックの改善のみならず、アルゴリズム自体の工夫をしなければならない。
この章では時間・空間制約がある場合のA*の代わりとなるヒューリスティック探索の発展を紹介する。
これらのアルゴリズムはメリット・デメリットがあり、問題・計算機環境によって有効な手法が異なる。よって、A*を完全に取って代わるものは一つもないと言える。

<P>

<H1><A NAME="SECTION00810000000000000000"></A>
<A NAME="sec:branch-and-bound"></A><BR>
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> Branch-and-Bound
</H1>
admissible pruning
 Branch and Bound
 wA* pruning (MSA)

<P>

<H1><A NAME="SECTION00820000000000000000"></A>
<A NAME="sec:iterative-deepening-astar"></A><BR>
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN> 反復深化A* (Iterative Deepening A*)
</H1>

<P>
A*探索は時間・空間の両方がボトルネックになるが、現代の計算機環境では多くの場合空間制約がよりネックになる。
これはA*が重複検出のために展開済みノードをすべてクローズドリストに保存していることに起因する。

<P>
<A HREF="#sec:graph-search-algorithm">3.4</A>節で述べたように、重複検出は正しい解を返すためには必須ではない。グラフに対して木探索を行うことも出来る。
しかしながら、単純な幅優先木探索・深さ優先木探索はパフォーマンスの問題がある。

<P>
反復深化A* (IDA*)は木探索に対してヒューリスティックを用いた、非常にメモリ効率の良いアルゴリズムである[<A
 HREF="textbook.html#korf:85a">21</A>]。
アルゴリズム<A HREF="#alg:iterative-deepening-astar">11</A>は反復深化A*の概要を示している。アイディアとしては、閾値<SPAN CLASS="MATH"><IMG
 WIDTH="32" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img229.png"
 ALT="$ cost$"></SPAN>を１ずつ大きくしながら、繰り返しコスト制限付き深さ優先木探索 (CLDFS)を実行する。コスト制限付き深さ優先探索が解を見つければその解を返して停止し、見つけられなければ<SPAN CLASS="MATH"><IMG
 WIDTH="32" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img230.png"
 ALT="$ cost$"></SPAN>を１つ大きくしてもう一度コスト制限付き深さ優先探索を実行する。

<P>
反復深化A*は閾値を大きくする度に一つ前のイテレーションで展開・生成したノードをすべて展開・生成しなおさなければならない。各イテレーション内でもクローズドリストを保持していないために重複検出が出来ない。なので、アルゴリズム全体を通して大量の重複ノードが出る可能性がある。
これは非常に効率が悪いように思えるかもしれないが、様々な状況においてA*よりも有用な手法である。

<P>
反復深化A*のメリットはいくつかある。
まず、コスト<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img231.png"
 ALT="$ w$"></SPAN>が0となるアクションが存在しない場合、必要なメモリ量が最適解のコストに対して線形である。深さ優先木探索は可能な最長経路だけのノードを保持する必要がある。木探索はクローズドリストは保持しない。コスト制限付きの場合、最長経路は<SPAN CLASS="MATH"><IMG
 WIDTH="32" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img232.png"
 ALT="$ cost$"></SPAN>以下である。<SPAN CLASS="MATH"><IMG
 WIDTH="74" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img233.png"
 ALT="$ 0&lt;w&lt;1$"></SPAN>となる実数コストがある場合、最小の<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img234.png"
 ALT="$ w$"></SPAN>が<SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img235.png"
 ALT="$ 1$"></SPAN>となるようにリスケールすることが出来る。 反復深化は<SPAN CLASS="MATH"><IMG
 WIDTH="32" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img236.png"
 ALT="$ cost$"></SPAN>が最適解のコストになった時に停止するので、必要なメモリ量は最適解のコストに対して線形である。
そのため、A*ではメモリが足りなくなって解けないような難しい問題でも反復深化A*なら解ける可能性がある。

<P>
メモリ量と関連してもう一つの重要なメリットはキャッシュ効率である。上述のように反復深化A*は必要なメモリ量が非常にすくない。また、メモリアクセスパターンもかなりリニアである。そのため、ほぼキャッシュミスなく探索を行えるドメインも多い。例えば、15-puzzleなどの状態が少ないビット数で表せられるドメインでは特にキャッシュ効率が良く、1ノードの展開速度の差は<B>TODO</B>倍という実験結果もある[<A
 HREF="textbook.html#korf:85a">21</A>]。実際、15-puzzleではIDA*のほうがA*よりも速く解を見つけることが出来る[<A
 HREF="textbook.html#korf:85a">21</A>]。何度も何度も重複して同じノードを展開しているのにも関わらずである。

<P>
反復深化A*は解を返す場合、得られた解が最適解であることを保証する。
反復深化A*をはじめとする重複検出のないアルゴリズムを用いる際の問題は、停止性を満たさないことである。すなわち、問題に解がなく、グラフにループがある場合、単純な木探索は停止しない。よって、この手法は解が間違いなく存在することが分かっている問題に対して適用される。あるいは、解が存在することを判定してから用いる。
例えば15-puzzleは解が存在するか非常に高速に判定することが出来る。

<P>
<BR>
<A NAME="alg:iterative-deepening-astar"></A><IMG
 WIDTH="556" HEIGHT="163" ALIGN="BOTTOM" BORDER="0"
 SRC="img237.png"
 ALT="\begin{algorithm}
% latex2html id marker 497\caption{Iterative Deepening A*}
...
...cost)$\;
\If {$found \neq \emptyset$} {
\Return $found$;
}
}
\end{algorithm}">
<BR>

<P>
<BR>
<A NAME="alg:cldfs"></A><IMG
 WIDTH="556" HEIGHT="222" ALIGN="BOTTOM" BORDER="0"
 SRC="img238.png"
 ALT="\begin{algorithm}
% latex2html id marker 506\caption{CLDFS: Cost Limited Depth...
... {
\Return sequence $(s, found)$\;
}
}
\Return $\emptyset$\;
\end{algorithm}">
<BR>

<P>

<H2><A NAME="SECTION00821000000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Transposition Table</A>
</H2>
<P>
反復深化A*で必要な空間は最適解のコストに対して線形である。
そうすると、むしろかなりの量のメモリが余ることになる。
そこで、メモリの余った分だけを使って重複検出をするというTransposition Tableという手法がある。
A*で用いられるClosedと異なり、このテーブルはすべての生成済みノードを保持しない。

<P>
ここでもミソは重複検出は生成済み

<P>

<H1><A NAME="SECTION00830000000000000000"></A>
<A NAME="sec:bidirectional-search"></A><BR>
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">3</SPAN> 両方向探索 (Bidirectional Search)
</H1>
<P>
状態空間グラフの特徴を理解するための重要な指標として枝分数(Branching factor)がある。枝分数はExpand関数によって得られる子ノードの数の平均である。
すなわち、重複検出をしないとすると、枝分数が<SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img239.png"
 ALT="$ b$"></SPAN>であるグラフにおいて深さ<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img240.png"
 ALT="$ d$"></SPAN>のノードの数はおおよそ<SPAN CLASS="MATH"><IMG
 WIDTH="35" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="img241.png"
 ALT="$ b^{d-1}$"></SPAN>である。
例えば15-puzzleはXであり、２次元４方向グリッド経路探索問題は４である。
幅優先探索において最も浅い解の深さが<SPAN CLASS="MATH"><IMG
 WIDTH="24" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img242.png"
 ALT="$ C^*$"></SPAN>であると仮定すると、少なくとも<SPAN CLASS="MATH"><IMG
 WIDTH="45" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img243.png"
 ALT="$ b^{C^*-2}$"></SPAN>個のノードをExpandしなければならない。

<P>

<H1><A NAME="SECTION00840000000000000000"></A>
<A NAME="sec:external-search"></A><BR>
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN> External Search
</H1>

<P>
グラフ探索は重複検出のために今までに展開したノードをすべて保持しなければならない。
よって、保持できるノードの量によって解ける問題が決まってくる。
探索空間があまりに大きすぎると、ノードが多すぎてメモリに乗り切らないということが起きる。

<P>
External Searchは外部記憶、HDDやSDDを用いることでこの問題を解決する。
すなわち、Open、Closedの一部を外部記憶に保持し、必要に応じて参照しRAMに持ってくる、ということをする。
External Searchのミソは、外部記憶へのアクセス回数をどのように減らすかにある。
表<A HREF="#tbl:latency">7.2</A>は一般的なコンピュータのキャッシュ・メモリ・ハードディスクへのアクセスレイテンシーを比較した表である。メモリから1MB<I>逐次に</I>読みだすオペレーションは250,000 nanosecかかるが、ハードディスクからの読出しは20,000,000 nanosecもかかる。更にハードディスクにランダムアクセスする場合(Disk seek)は8,000,000 nanosecもかかる。
よって、HDDは工夫して使わなければ実行時間が非常に遅くなってしまう。

<P>
<BR><P></P>
<DIV ALIGN="CENTER">
<DIV ALIGN="CENTER">

</DIV>
<A NAME="tbl:latency"></A><A NAME="527"></A>
<TABLE CELLPADDING=3 BORDER="1">
<CAPTION><STRONG>Table 7.2:</STRONG>
一般的なハードウェアのアクセス速度。メモリへのアクセス速度に対して外部記憶のアクセスは遅い。加えて、ランダムアクセスはseekの時間がかかるためさらに遅くなる。 (https://gist.github.com/jboner/2841832)</CAPTION>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="RIGHT">nano sec</TD>
</TR>
<TR><TD ALIGN="LEFT">命令実行</TD>
<TD ALIGN="RIGHT">1</TD>
</TR>
<TR><TD ALIGN="LEFT">fetch from L1 cache memory</TD>
<TD ALIGN="RIGHT">0.5</TD>
</TR>
<TR><TD ALIGN="LEFT">branch misprediction</TD>
<TD ALIGN="RIGHT">5</TD>
</TR>
<TR><TD ALIGN="LEFT">fetch from L2 cache memory</TD>
<TD ALIGN="RIGHT">7</TD>
</TR>
<TR><TD ALIGN="LEFT">mutex lock/unlock</TD>
<TD ALIGN="RIGHT">25</TD>
</TR>
<TR><TD ALIGN="LEFT">fetch from main memory</TD>
<TD ALIGN="RIGHT">100</TD>
</TR>
<TR><TD ALIGN="LEFT">Read 4K randomly from SSD</TD>
<TD ALIGN="RIGHT">150,000</TD>
</TR>
<TR><TD ALIGN="LEFT">read 1MB sequentially from memory</TD>
<TD ALIGN="RIGHT">250,000</TD>
</TR>
<TR><TD ALIGN="LEFT">fetch from new disk location (seek)</TD>
<TD ALIGN="RIGHT">8,000,000</TD>
</TR>
<TR><TD ALIGN="LEFT">Read 1 MB sequentially from SSD</TD>
<TD ALIGN="RIGHT">1,000,000</TD>
</TR>
<TR><TD ALIGN="LEFT">read 1MB sequentially from disk</TD>
<TD ALIGN="RIGHT">20,000,000</TD>
</TR>
</TABLE>
</DIV><BR>

<P>

<H2><A NAME="SECTION00841000000000000000"></A>
<A NAME="sec:external-brfs"></A><BR>
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> External 幅優先探索
</H2>

<P>
<BR>
<A NAME="alg:external-brfs"></A><IMG
 WIDTH="556" HEIGHT="298" ALIGN="BOTTOM" BORDER="0"
 SRC="img244.png"
 ALT="\begin{algorithm}
% latex2html id marker 535\caption{External Breadth-first se...
...n(i-2))$\;
$i \leftarrow i + 1$\;
}
\Return No solution found
\end{algorithm}">
<BR>

<P>

<H2><A NAME="SECTION00842000000000000000"></A>
<A NAME="sec:external-astar"></A><BR>
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> External A*
</H2>
<P>
<BR>
<A NAME="alg:external-astar"></A><IMG
 WIDTH="556" HEIGHT="105" ALIGN="BOTTOM" BORDER="0"
 SRC="img245.png"
 ALT="\begin{algorithm}
% latex2html id marker 546\caption{External A* search}
\Inp...
... path with cost $\leq cost$}
\par
XXX
\Return No solution found
\end{algorithm}">
<BR>

<P>

<H1><A NAME="SECTION00850000000000000000"></A>
<A NAME="sec:symbolic-search"></A><BR>
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN> Symbolic Search
</H1>
Binary Decision Diagram (BDD)は二分木によってブーリアンvectorからブーリアンへの関数<!-- MATH
 $(x_0,x_1,...,x_n) \rightarrow \{0, 1\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="165" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img246.png"
 ALT="$ (x_0,x_1,...,x_n) \rightarrow \{0, 1\}$"></SPAN>を効率良く表すグラフ構造である。
Symbolic SearchではBDDを使って状態の集合、アクションの集合を表し、BDD同士の演算によって状態の集合を一気に同時に展開していく。
A*探索がノードを一つずつ展開していき、一つずつ生成していく手間と比較して非常に効率的に演算が出来るポテンシャルを秘めている。
International Planning Competition (2014)のSequential Optimal部門(最適解を見つけるパフォーマンスを競う部門)の一位から三位までをSymbolic Searchが総なめした。現在(2017年)のstate-of-the-artの手法であるといえるだろう。

<P>

<H2><A NAME="SECTION00851000000000000000"></A>
<A NAME="sec:symbolic-representation"></A><BR>
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> 特徴表現 (Symbolic Representation)
</H2>

<P>
説明のためにシンプルなSliding-token puzzleを用いる(図<A HREF="#fig:sliding-token">7.1</A>)。
初期状態でタイルは位置０にある。タイルは右か左に動かすことが出来る。ゴール状態はタイルを位置３に置いた状態である。
タイルの位置<!-- MATH
 $x (dom(x) = \{0,1,2,3\})$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="167" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img247.png"
 ALT="$ x (dom(x) = \{0,1,2,3\})$"></SPAN>はバイナリ<SPAN CLASS="MATH"><IMG
 WIDTH="56" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img248.png"
 ALT="$ (x_0,x_1)$"></SPAN>に変換されている。
状態および状態の集合は特徴関数<!-- MATH
 $\phi: S \rightarrow \{0, 1\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="101" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img249.png"
 ALT="$ \phi: S \rightarrow \{0, 1\}$"></SPAN>によって記述される。

<P>
例えば<!-- MATH
 $S = \{0, 1\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="75" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img250.png"
 ALT="$ S = \{0, 1\}$"></SPAN>とすると、<!-- MATH
 $\phi_{S}(x)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="44" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img251.png"
 ALT="$ \phi_{S}(x)$"></SPAN>は<SPAN CLASS="MATH"><IMG
 WIDTH="43" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img252.png"
 ALT="$ x \in S$"></SPAN>の場合に(かつその場合のみに)真を返す特徴関数は<SPAN CLASS="MATH"><IMG
 WIDTH="31" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img253.png"
 ALT="$ \lnot x_0$"></SPAN>である。面白いことに、1つの状態のみを含む状態集合<!-- MATH
 $S' = \{0\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="64" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img254.png"
 ALT="$ S' = \{0\}$"></SPAN>を表す特徴関数よりも要素２つの<SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img255.png"
 ALT="$ S$"></SPAN>を表す特徴関数の方が表現がコンパクトになる。
このように、特徴表現は明示的に列挙するよりも状態の集合をコンパクトに表現出来る場合がある。

<P>
アクションによる状態遷移も特徴関数<!-- MATH
 $Trans: S \times S \rightarrow \{0, 1\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="166" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img256.png"
 ALT="$ Trans: S \times S \rightarrow \{0, 1\}$"></SPAN>によって定義される。アクション<SPAN CLASS="MATH"><IMG
 WIDTH="44" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img257.png"
 ALT="$ a \in A$"></SPAN>によって状態<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img258.png"
 ALT="$ x$"></SPAN>から<SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img259.png"
 ALT="$ x'$"></SPAN>に遷移するならば、<!-- MATH
 $Trans_a(x,x')$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="99" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img260.png"
 ALT="$ Trans_a(x,x')$"></SPAN>は真を返す(かつその時のみ)。
アクション集合<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img261.png"
 ALT="$ A$"></SPAN>による遷移は<!-- MATH
 $Trans(x,x')$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="91" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img262.png"
 ALT="$ Trans(x,x')$"></SPAN>によって表現され、<!-- MATH
 $Trans(x,x')$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="91" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img263.png"
 ALT="$ Trans(x,x')$"></SPAN>は<!-- MATH
 $Trans_a(x,x')$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="99" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img264.png"
 ALT="$ Trans_a(x,x')$"></SPAN>が真となる<SPAN CLASS="MATH"><IMG
 WIDTH="44" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img265.png"
 ALT="$ a \in A$"></SPAN>が存在する場合に真を返す(かつその時のみ)。

<P>
Sliding-token puzzleで可能なアクションは<!-- MATH
 $(00) \rightarrow (01), (01) \rightarrow (00), (01) \rightarrow (10), (10) \rightarrow (01), (10) \rightarrow (11), (11) \rightarrow (10)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="528" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img266.png"
 ALT="$ (00) \rightarrow (01), (01) \rightarrow (00), (01) \rightarrow (10), (10) \rightarrow (01), (10) \rightarrow (11), (11) \rightarrow (10)$"></SPAN>の６つである。これらを表す遷移関数は

<P>
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay"><!-- MATH
 \begin{equation}
\begin{split}
	Trans(x,x') &= (\lnot x_0 \lnot x_1 \lnot x'_0 x'_1) \\
		&\lor (\lnot x_0 x_1 \lnot x'_0 \lnot x'_1) \\
		&\lor (\lnot x_0 x_1 x'_0 \lnot x'_1) \\
		&\lor (x_0 \lnot x_1 \lnot x'_0 x'_1) \\
		&\lor (x_0 \lnot x_1 x'_0 x'_1) \\
		&\lor (x_0 x_1 x'_0 \lnot x'_1)
\end{split}
\end{equation}
 -->
<TABLE CLASS="equation" CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="216" HEIGHT="145" BORDER="0"
 SRC="img267.png"
 ALT="\begin{displaymath}\begin{split}Trans(x,x') &amp;= (\lnot x_0 \lnot x_1 \lnot x'_0 x...
...t x_1 x'_0 x'_1) \\ &amp;\lor (x_0 x_1 x'_0 \lnot x'_1) \end{split}\end{displaymath}"></SPAN></TD>
<TD NOWRAP CLASS="eqno" WIDTH="10" ALIGN="RIGHT">
(<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>

<P>
となる。
アクションのコストがある場合は<!-- MATH
 $Trans(w, x, x')$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="110" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img268.png"
 ALT="$ Trans(w, x, x')$"></SPAN>として表現され、<!-- MATH
 $Trans(x,x')$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="91" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img269.png"
 ALT="$ Trans(x,x')$"></SPAN>は<!-- MATH
 $Trans_a(x,x')$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="99" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img270.png"
 ALT="$ Trans_a(x,x')$"></SPAN>が真となる<SPAN CLASS="MATH"><IMG
 WIDTH="44" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img271.png"
 ALT="$ a \in A$"></SPAN>が存在し、かつそのアクションのコストが<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img272.png"
 ALT="$ w$"></SPAN>である場合に真を返す(かつその時のみ)。

<P>

<DIV ALIGN="CENTER"><A NAME="fig:sliding-token"></A><A NAME="564"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 7.1:</STRONG>
Sliding-token puzzleとそのバイナリ表現</CAPTION>
<TR><TD><IMG
  WIDTH="271" HEIGHT="75" ALIGN="BOTTOM" BORDER="0"
 SRC="./sliding-token.png"
 ALT="Image sliding-token"></TD></TR>
</TABLE>
</DIV>

<P>
<BR><P></P>
<DIV ALIGN="CENTER">
<DIV ALIGN="CENTER">

</DIV>
<A NAME="tbl:sliding-token"></A><A NAME="568"></A>
<TABLE CELLPADDING=3 BORDER="1">
<CAPTION><STRONG>Table 7.3:</STRONG>
Sliding-token puzzleのエンコーディング</CAPTION>
<TR><TD ALIGN="CENTER">State ID</TD>
<TD ALIGN="CENTER">State Role</TD>
<TD ALIGN="CENTER">Binary Code</TD>
<TD ALIGN="CENTER">Boolean Formula</TD>
</TR>
<TR><TD ALIGN="CENTER">0</TD>
<TD ALIGN="CENTER">初期状態</TD>
<TD ALIGN="CENTER">00</TD>
<TD ALIGN="CENTER"><!-- MATH
 $\lnot x_0 \lnot x_1$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="58" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img273.png"
 ALT="$ \lnot x_0 \lnot x_1$"></SPAN></TD>
</TR>
<TR><TD ALIGN="CENTER">1</TD>
<TD ALIGN="CENTER">-</TD>
<TD ALIGN="CENTER">01</TD>
<TD ALIGN="CENTER"><!-- MATH
 $\lnot x_0  x_1$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="47" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img274.png"
 ALT="$ \lnot x_0 x_1$"></SPAN></TD>
</TR>
<TR><TD ALIGN="CENTER">2</TD>
<TD ALIGN="CENTER">-</TD>
<TD ALIGN="CENTER">10</TD>
<TD ALIGN="CENTER"><!-- MATH
 $x_0 \lnot x_1$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="47" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img275.png"
 ALT="$ x_0 \lnot x_1$"></SPAN></TD>
</TR>
<TR><TD ALIGN="CENTER">3</TD>
<TD ALIGN="CENTER">ゴール状態</TD>
<TD ALIGN="CENTER">11</TD>
<TD ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img276.png"
 ALT="$ x_0 x_1$"></SPAN></TD>
</TR>
</TABLE>
</DIV><BR>

<P>

<H2><A NAME="SECTION00852000000000000000"></A>
<A NAME="sec:binary-decision-diagram"></A><BR>
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> Binary Decision Diagram
</H2>

<P>
状態集合およびアクション集合は<B>Binary Decision Diagram</B> (BDD) <A NAME="852"></A><A NAME="853"></A>でコンパクトに表現することが出来る。

<P>
<P><DIV><B>Definition  <SPAN CLASS="arabic">9</SPAN></B> &nbsp; 
<I>BDD
BDDはループのない有向グラフであり、ノードとエッジはラベルが付いている。単一の根ノードと２つのシンクがあり、シンクのラベルは1と0である。sink以外のノードのラベルは変数<!-- MATH
 $x_i (i \in \{1,...,n\})$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="117" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img277.png"
 ALT="$ x_i (i \in \{1,...,n\})$"></SPAN>であり、エッジのラベルは1か0である。</I></DIV><P></P>

<P>
BDDは決定木と同様な処理によって入力<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img278.png"
 ALT="$ x$"></SPAN>に対して<SPAN CLASS="MATH"><IMG
 WIDTH="43" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img279.png"
 ALT="$ \{1, 0\}$"></SPAN>を返す。
すなわち、根ノードから始まり、ノードのラベル<SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img280.png"
 ALT="$ x_i$"></SPAN>に対して、入力<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img281.png"
 ALT="$ x$"></SPAN>の<SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img282.png"
 ALT="$ x_i$"></SPAN>が1であればラベル1が付いたエッジをたどり、0であればラベル0をたどる。これを繰り返し、シンクにたどり着いたらシンクのラベルの値を返す。
決定木と異なりBDDは木ではなく、途中で合流などがあるため、決定木よりも空間効率が良い場合が多い。
BDDを用いて集合演算を行うことが出来る。

<P>
BDDを使って状態やアクションの特徴関数を表現することが出来る。

<P>

<H2><A NAME="SECTION00853000000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> 特徴関数による状態空間の探索</A>
</H2>

<P>
状態空間の探索は特徴関数の演算によって表現することが出来、その演算はBDDの演算によって実装することが出来る。

<P>
ある状態集合<SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img283.png"
 ALT="$ S$"></SPAN>に対して、<SPAN CLASS="MATH"><IMG
 WIDTH="42" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img284.png"
 ALT="$ s \in S$"></SPAN>となる<SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img285.png"
 ALT="$ s$"></SPAN>の次状態の集合を<SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img286.png"
 ALT="$ S$"></SPAN>の<I>image</I>と呼ぶ。
<SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img287.png"
 ALT="$ S$"></SPAN>のimageは以下の特徴関数によって表すことが出来る。

<P>
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay"><!-- MATH
 \begin{equation}
Image_S(x') = \exists x (Trans(x,x') \land \phi_S(x))
\end{equation}
 -->
<TABLE CLASS="equation" CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="282" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img288.png"
 ALT="$\displaystyle Image_S(x') = \exists x (Trans(x,x') \land \phi_S(x))$"></SPAN></TD>
<TD NOWRAP CLASS="eqno" WIDTH="10" ALIGN="RIGHT">
(<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>

<P>

<H3><A NAME="SECTION00853100000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> BDD-幅優先木探索</A>
</H3>

<P>
imageを繰り返し求めていくことで幅優先木探索は簡単に実装することが出来る。
まず、初期状態<SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img289.png"
 ALT="$ s_0$"></SPAN>だけによる集合<!-- MATH
 $S_0 = \{s_0\}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="73" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img290.png"
 ALT="$ S_0 = \{s_0\}$"></SPAN>を考える。これに対して<!-- MATH
 $\phi_{S_{i}}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="27" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img291.png"
 ALT="$ \phi_{S_{i}}$"></SPAN>は集合<SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img292.png"
 ALT="$ S_i$"></SPAN>を表す特徴関数だとする。これを用いることで次状態集合を次々と求めることが出来る：

<P>
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay"><!-- MATH
 \begin{equation}
\phi_{S_i}(x') = \exists x (\phi_{S_{i-1}}(x) \land Trans(x,x'))
\end{equation}
 -->
<TABLE CLASS="equation" CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="268" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img293.png"
 ALT="$\displaystyle \phi_{S_i}(x') = \exists x (\phi_{S_{i-1}}(x) \land Trans(x,x'))$"></SPAN></TD>
<TD NOWRAP CLASS="eqno" WIDTH="10" ALIGN="RIGHT">
(<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">3</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>

<P>
簡単に言えば、状態<SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img294.png"
 ALT="$ x'$"></SPAN>は、もし親状態<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img295.png"
 ALT="$ x$"></SPAN>が<SPAN CLASS="MATH"><IMG
 WIDTH="36" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img296.png"
 ALT="$ S_{i-1}$"></SPAN>に含まれていれば、<SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img297.png"
 ALT="$ S_i$"></SPAN>に含まれる。
探索を停止するためには探索した状態にゴール状態が含まれているかをテストしなければならない。
ゴールテストも特徴関数を用いて表すことが出来る。
ゴール状態集合<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img298.png"
 ALT="$ T$"></SPAN>を表す特徴関数を<SPAN CLASS="MATH"><IMG
 WIDTH="24" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img299.png"
 ALT="$ \phi_T$"></SPAN>とすると、<!-- MATH
 $\phi_{S_i}(x') \land \phi_T \neq false$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="150" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img300.png"
 ALT="$ \phi_{S_i}(x') \land \phi_T \neq false$"></SPAN>であれば<SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img301.png"
 ALT="$ S_i$"></SPAN>はゴール状態を含む。

<P>
アルゴリズム<A HREF="#alg:symbolic-brfs-tree"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>はBDD-幅優先木探索である。
imageの計算とゴールテストによって実装することが出来る。

<P>
<BR>
<A NAME="alg:bdd-brfs-tree"></A><IMG
 WIDTH="556" HEIGHT="163" ALIGN="BOTTOM" BORDER="0"
 SRC="img302.png"
 ALT="\begin{algorithm}
% latex2html id marker 594\caption{BDD Breadth-first Tree Se...
...e$} {
\Return $Construct(\phi_{S_i} \land \phi_T(x), i)$\;
}
}\end{algorithm}">
<BR>

<P>
<SPAN CLASS="MATH"><IMG
 WIDTH="77" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img303.png"
 ALT="$ Construct$"></SPAN>関数はゴールに至るための経路を計算する関数である。
<!-- MATH
 $\phi_{S_i} \land \phi_T(x)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="86" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img304.png"
 ALT="$ \phi_{S_i} \land \phi_T(x)$"></SPAN>によってゴール状態、解経路における<SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img305.png"
 ALT="$ i$"></SPAN>ステップ目の状態(<SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img306.png"
 ALT="$ s_i$"></SPAN>)が得られる。次に<!-- MATH
 $Trans(\phi_{S_{i-1}}, s_i)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="118" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img307.png"
 ALT="$ Trans(\phi_{S_{i-1}}, s_i)$"></SPAN>によって<SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img308.png"
 ALT="$ i-1$"></SPAN>ステップ目の状態<SPAN CLASS="MATH"><IMG
 WIDTH="33" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img309.png"
 ALT="$ s_{i-1}$"></SPAN>が得られ、<SPAN CLASS="MATH"><IMG
 WIDTH="56" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img310.png"
 ALT="$ Trans_a$"></SPAN>を見ていくことで<SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img311.png"
 ALT="$ i-1$"></SPAN>ステップ目のアクションが得られる。これを繰り返すことによって元の解経路を復元することが出来る。ゴール状態は一つ取り出せば十分であるため、<SPAN CLASS="MATH"><IMG
 WIDTH="77" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img312.png"
 ALT="$ Construct$"></SPAN>の計算時間は大きくはない。

<P>
BDD-幅優先木探索は幅優先探索と同様、解の経路長が最短であることを保証する。

<P>

<H3><A NAME="SECTION00853200000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> BDD-幅優先探索</A>
</H3>

<P>
重複検出を行う場合はクローズドリストに展開済みノードを保存する必要がある。
この展開済みノードも特徴関数及びBDDで表すことが出来る。
アルゴリズム<A HREF="#alg:bdd-brfs">16</A>はBDD-幅優先探索のコードである。
アルゴリズム<A HREF="#alg:bdd-brfs-tree">15</A>と異なり特徴関数<SPAN CLASS="MATH"><IMG
 WIDTH="53" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img313.png"
 ALT="$ Closed$"></SPAN>を用いて重複検出を行っている。

<P>
<BR>
<A NAME="alg:bdd-brfs"></A><IMG
 WIDTH="556" HEIGHT="220" ALIGN="BOTTOM" BORDER="0"
 SRC="img314.png"
 ALT="\begin{algorithm}
% latex2html id marker 611\caption{BDD Breadth-first search}...
...e$} {
\Return $Construct(\phi_{S_i} \land \phi_T(x), i)$\;
}
}\end{algorithm}">
<BR>

<P>

<H3><A NAME="SECTION00853300000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> BDD-最適コスト探索</A>
</H3>

<P>

<H1><A NAME="SECTION00860000000000000000"></A>
<A NAME="sec:parallel-search"></A><BR>
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN> 並列探索 (Parallel Search)
</H1>

<P>
近年コンピュータ一台当たりのコア数は増加を続けており、コンピュータクラスタにも比較的容易にアクセスが出来るようになった。Amazon Web Serviceのようなクラウドの計算資源も普及し、将来的には並列化が当然になると考えられる。
並列化の成功例は枚挙にいとまないが、近年のディープラーニングはまさに効率的な並列計算アーキテクチャによって得られたブレイクスルーであるといえる。
もしCPU/GPUを利用した効率的なグラフ探索アルゴリズムが開発出来れば、非常に大きなインパクトになるかもしれない。グラフ探索アルゴリズムの並列化に考えなければならないオーバーヘッドは様々であり、それらの重要性は問題、インスタンス、マシン、さまざまな状況に依存する。加えてハードウェアは刻々と変化を続けており、数年後にどのような環境がメジャーとなるのかはなかなか想像をすることが出来ないだろう。
本書ではCPUを用いた分散メモリ並列アルゴリズムとGPU一台を用いた並列アルゴリズムについて説明する。
CPU並列ではハッシュによってノードを各プロセスにアサインし、各プロセスはアサインされたノードのみを担当して探索を行うというフレームワークが現在のstate-of-the-artである。
一方、執筆時現在、GPUを用いたアルゴリズムはあまり研究が進んでいない。原因としては、既存のCPUを用いた探索アルゴリズムにはない様々な難しさがあるだろう。
たとえば、GPUはスレッド当りのメモリ量が非常に少ない。A*探索はメモリが大きなボトルネックであり、メモリ量が少ないとそのまま解ける問題の大きさが制限されてしまう。この問題を解決する方法は提示されていない。
もうひとつの難しさは、GPUは複数のスレッドが同じ命令を実行するSingle instruction multiple thread (SIMT)という計算モデルであることである。そのため、既知の有力なヒューリスティック関数をGPU環境において効率的に実装する方法が自明ではない。
パターンデータベースなどのシンプルな命令によるヒューリスティックも考えることが出来るが、このようなヒューリスティックは今度はメモリを沢山消費するという問題点がある。
効率的なGPU並列化アルゴリズムの開発は大きな成果が期待されるブルーオーシャンであるといえる<A NAME="tex2html21"
  HREF="#foot625"><SUP><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN></SUP></A>。

<P>

<H2><A NAME="SECTION00861000000000000000"></A>
<A NAME="sec:parallel-overheads"></A><BR>
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> 並列化オーバーヘッド
</H2>

<P>
理想的には<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img315.png"
 ALT="$ n$"></SPAN>プロセスで並列化したら<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img316.png"
 ALT="$ n$"></SPAN>倍速くなってほしい。
逐次アルゴリズムと比較して、プロセス数倍の高速化が得られることを<I>perfect linear speedup</I>と呼ぶ。
しかしながら、殆どの場合perfect linear speedupは得られない。
それは並列化にさいして様々なオーバーヘッドがかかるからである。
[<A
 HREF="textbook.html#jinnai2017work">17</A>]の記法に従うと、並列化オーバーヘッドは主に以下の３つに分けられる。

<P>
<B>通信オーべーヘッド (Communication overhead, CO)</B>:
通信オーバーヘッドはプロセス間で情報交換を行うことにかかるオーバーヘッドである。
通信する情報は様々なものが考えられるが、オーバーヘッドとなるものはノードの生成回数に比例した回数通信を必要とするものである。
すなわち、ノードの生成回数<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img317.png"
 ALT="$ n$"></SPAN>に対して<SPAN CLASS="MATH"><IMG
 WIDTH="47" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img318.png"
 ALT="$ log(n)$"></SPAN>回しか通信を行わない場合、その通信によるオーバーヘッドは無視出来るだろう。
ここではノードの生成回数に対するメッセージ送信の割合をCOと定義する：
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay"><!-- MATH
 \begin{equation}
CO := \frac{\text{\# messages sent to other threads}}{\text{\# nodes generated}}.
\end{equation}
 -->
<TABLE CLASS="equation" CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="268" HEIGHT="51" ALIGN="MIDDLE" BORDER="0"
 SRC="img319.png"
 ALT="$\displaystyle CO := \frac{\text{\char93  messages sent to other threads}}{\text{\char93  nodes generated}}.$"></SPAN></TD>
<TD NOWRAP CLASS="eqno" WIDTH="10" ALIGN="RIGHT">
(<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>

<P>
例えば、ハッシュなどによってプロセス間でノードの送受信を行いロードバランスを行う手法の場合、通信するメッセージは主にノードである。この場合：

<P>
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay"><!-- MATH
 \begin{equation}
CO := \frac{\text{\# nodes sent to other threads}}{\text{\# nodes generated}}.
\end{equation}
 -->
<TABLE CLASS="equation" CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="245" HEIGHT="51" ALIGN="MIDDLE" BORDER="0"
 SRC="img320.png"
 ALT="$\displaystyle CO := \frac{\text{\char93  nodes sent to other threads}}{\text{\char93  nodes generated}}.$"></SPAN></TD>
<TD NOWRAP CLASS="eqno" WIDTH="10" ALIGN="RIGHT">
(<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>
となる。
COは通信にかかるディレイだけでなく、メッセージキューなどのデータ構造の操作も行わなければならないので、特にノードの展開速度が速いドメインにおいて重要なオーバーヘッドになる。一般に、プロセス数が多いほどCOは大きくなる。
<P>
<B>探索オーバーヘッド (Search Overhead, SO):</B>
一般に並列探索は逐次探索より多くのノードを展開することになる。
このとき、余分に展開したノードは逐次と比較して増えた仕事量だと言える。
本書では以下のように探索オーバーヘッドを定義する：

<P>
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay"><!-- MATH
 \begin{equation}
SO := \frac{\text{\# nodes expanded in parallel}}{\text{\#nodes expanded in sequential search}} - 1.
\end{equation}
 -->
<TABLE CLASS="equation" CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="328" HEIGHT="51" ALIGN="MIDDLE" BORDER="0"
 SRC="img321.png"
 ALT="$\displaystyle SO := \frac{\text{\char93  nodes expanded in parallel}}{\text{\char93 nodes expanded in sequential search}} - 1.$"></SPAN></TD>
<TD NOWRAP CLASS="eqno" WIDTH="10" ALIGN="RIGHT">
(<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>

<P>
SOはロードバランス (load balance, LB)が悪い場合に生じることが多い。

<P>
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay"><!-- MATH
 \begin{equation}
LB := \frac{\text{Maximum number of nodes assigned to a thread}}{\text{Average number of nodes assigned to a thread}}.
\end{equation}
 -->
<TABLE CLASS="equation" CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="369" HEIGHT="51" ALIGN="MIDDLE" BORDER="0"
 SRC="img322.png"
 ALT="$\displaystyle LB := \frac{\text{Maximum number of nodes assigned to a thread}}{\text{Average number of nodes assigned to a thread}}.$"></SPAN></TD>
<TD NOWRAP CLASS="eqno" WIDTH="10" ALIGN="RIGHT">
(<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>

<P>
ロードバランスが悪いと、ノードが集中しているスレッドがボトルネックとなり、他のスレッドはノードがなくなるか、あるいはよりf値の大きい(有望でない)ノードを展開することになり、探索オーバーヘッドになる。

<P>
探索オーバーヘッドは実行時間だけでなく、空間オーバーヘッドでもある。ムダに探索をした分だけ、消費するメモリ量も多くなる。分散メモリ環境においてもコア当りのRAM量は大きくなるわけではないので、探索オーバーヘッドによるメモリ消費は問題となる。

<P>
<B>同期オーバーヘッド (Coordination Overhead)</B>
同期オーバーヘッドは他のスレッドの処理を待つためにアイドル状態にならなければならない時に生じるオーバーヘッドを指す。
アルゴリズム自体が同期を必要としないものだとしても、メモリバスのコンテンションによって同期オーバーヘッドが生じることがある[<A
 HREF="textbook.html#burnslrz10">5</A>,<A
 HREF="textbook.html#kishimotofb13">20</A>].

<P>
これらのオーバーヘッドは独立ではなく、むしろ相互に関係しており、トレードオフの関係にある。
多くの場合、通信・同期オーバーヘッドと探索オーバーヘッドがトレードオフの関係にあたる。

<P>

<H2><A NAME="SECTION00862000000000000000"></A>
<A NAME="sec:hash-distributed-astar"></A><BR>
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> Hash Distributed A*
</H2>

<P>
ハッシュ分配A* (Hash Distributed A*, HDA*) [<A
 HREF="textbook.html#kishimotofb13">20</A>]はCPUを用いたstate-of-the-artの並列A*探索アルゴリズムである。
HDA*の各プロセスはそれぞれローカルなオープンリスト、クローズドリストを保持する。ローカルとは、データ構造を保持するプロセスが独占してアクセスを行い、他のプロセスからはアクセスが不可能であるという意味である。
グローバルなハッシュ関数によって全ての状態は一意に定まる担当のプロセスが定められる。
各プロセス<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img323.png"
 ALT="$ T$"></SPAN>の動作は以下を繰り返す：

<P>

<OL>
<LI>プロセス<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img324.png"
 ALT="$ T$"></SPAN>はメッセージキューを確認し、ノードが届いているかを確認する。届いているノードのうち重複でないものをオープンリストに加える(A*同様、クローズドリストに同じ状態が存在しないか、クローズドリストにある同じ状態のノードよりも<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img325.png"
 ALT="$ f$"></SPAN>値が小さい場合に重複でない)。
</LI>
<LI>オープンリストにあるノードのうち最もプライオリティ(<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img326.png"
 ALT="$ f$"></SPAN>値)の高いノードを展開する。生成されたそれぞれのノード<SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img327.png"
 ALT="$ n$"></SPAN>についてハッシュ値<SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img328.png"
 ALT="$ H(n)$"></SPAN>を計算し、ハッシュ値<SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img329.png"
 ALT="$ H(n)$"></SPAN>を担当するプロセスに非同期的に送信される。
</LI>
</OL>

<P>
HDA*の重要な特徴は２つある。
まず、HDA*は非同期通信を行うため、同期オーバーヘッドが非常に小さい。
各プロセスがそれぞれローカルにオープン・クローズドリストを保持するため、これらのデータ構造へのアクセスにロックを必要としない。
次に、HDA*は手法が非常にシンプルであり、ハッシュ関数<!-- MATH
 $Hash: S \rightarrow {1..P}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="122" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img330.png"
 ALT="$ Hash: S \rightarrow {1..P}$"></SPAN>を必要とするだけである (<SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img331.png"
 ALT="$ P$"></SPAN>はプロセス数)。しかしながらハッシュ関数は通信オーバーヘッドとロードバランスの両方を決定する為、その選択はパフォーマンスに非常に大きな影響を与える。

<P>
HDA*が提案された論文[<A
 HREF="textbook.html#kishimotofb13">20</A>]ではZobrist hashing [<A
 HREF="textbook.html#zobrist:70">34</A>]がハッシュ関数として用いられていた。
状態<!-- MATH
 $s = (x_1,x_2,...,x_n)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="130" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img332.png"
 ALT="$ s = (x_1,x_2,...,x_n)$"></SPAN>に対してZobrist hashingのハッシュ値<SPAN CLASS="MATH"><IMG
 WIDTH="36" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img333.png"
 ALT="$ Z(s)$"></SPAN>は以下のように計算される：

<P>
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay"><A NAME="eq:zobrist"></A><!-- MATH
 \begin{equation}
Z(s) := R_{0}[x_{0}]\; xor\; R_{1}[x_{1}]\; xor\; \cdots\; xor\; R_{n}[x_{n}]%
\end{equation}
 -->
<TABLE CLASS="equation" CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="525" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img334.png"
 ALT="$\displaystyle Z(s) := R_{0}[x_{0}]\; xor\; R_{1}[x_{1}]\; xor\; \cdots\; xor\; R_{n}[x_{n}]&lt;tex2html_comment_mark&gt;$"></SPAN></TD>
<TD NOWRAP CLASS="eqno" WIDTH="10" ALIGN="RIGHT">
(<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">8</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>

<P>
Zobrist hashingは初めにランダムテーブル<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img335.png"
 ALT="$ R$"></SPAN>を初期化する<A HREF="#alg:init-zobrist-hashing">18</A>。
これを用いてハッシュ値を計算する。

<P>
<BR>
<A NAME="alg:zobrist-hashing"></A><IMG
 WIDTH="556" HEIGHT="126" ALIGN="BOTTOM" BORDER="0"
 SRC="img336.png"
 ALT="\begin{algorithm}
% latex2html id marker 668\Input{$s = (x_0, x_1,...,x_n)$}
...
... xor \; R[x_i]$\;
}
{\bf Return} $hash$\;
\caption{ZHDA*{}}
\end{algorithm}">
<BR>

<P>
<BR>
<A NAME="alg:init-zobrist-hashing"></A><IMG
 WIDTH="556" HEIGHT="127" ALIGN="BOTTOM" BORDER="0"
 SRC="img337.png"
 ALT="\begin{algorithm}
% latex2html id marker 676\Input{$V = (dom(x_0),dom(x_1),.....
...Return} $R = (R_1, R_2,...,R_n)$
\caption{Initialize ZHDA*{}}
\end{algorithm}">
<BR>

<P>
Zobrist hashingを使うメリットは２つある。
一つは計算が非常に速いことである、XOR命令はCPUの演算で最も速いものの一つである。かつ、状態の差分を参照することでハッシュ値を計算することが出来るので、アクション適用によって値が変化した変数の<SPAN CLASS="MATH"><IMG
 WIDTH="34" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img338.png"
 ALT="$ R[x]$"></SPAN>のみ参照すれば良い。
もうひとつは、状態が非常にバランスよく分配され、ロードバランスが良いことである。
一方、この手法の問題点は通信オーバーヘッドが大きくなってしまうことにある。
この問題を解決するためにState abstractionという手法が提案された[<A
 HREF="textbook.html#burnslrz10">5</A>]。
State abstractionは状態<!-- MATH
 $s = (x_1,x_2,...,x_n)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="130" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img339.png"
 ALT="$ s = (x_1,x_2,...,x_n)$"></SPAN>に対して簡約化状態 (abstract state) <!-- MATH
 $s' = (x_1',x_2',...,x_m'), where m < n, x_i' = x_j (1 \leq j \leq n)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="371" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img340.png"
 ALT="$ s' = (x_1',x_2',...,x_m'), where m &lt; n, x_i' = x_j (1 \leq j \leq n)$"></SPAN>. 
State abstractionは簡約化状態からハッシュ値への関数の定義はされておらず、単純なlinear congrugent hashingが用いられていた。そのため、ロードバランスが悪かった。

<P>
Abstract Zobrist hashing (AZH)はZobrist hashingとAbstractionの良い点を組み合わせた手法である[<A
 HREF="textbook.html#jinnai2016structured">15</A>]。AZHはfeatureからabstract featureへのマッピングを行い、abstract featureをZobrist hashingへの入力とするという手法である：

<P>
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay"><A NAME="eq:abstract-zobrist"></A><!-- MATH
 \begin{equation}
Z(s) := R_{0}[A_0(x_{0})]\; xor\; R_{1}[A_1(x_{1})]\; xor\; \cdots\; xor\; R_{n}[A_n(x_{n})]%
\end{equation}
 -->
<TABLE CLASS="equation" CELLPADDING="0" WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD NOWRAP ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="617" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img341.png"
 ALT="$\displaystyle Z(s) := R_{0}[A_0(x_{0})]\; xor\; R_{1}[A_1(x_{1})]\; xor\; \cdots\; xor\; R_{n}[A_n(x_{n})]&lt;tex2html_comment_mark&gt;$"></SPAN></TD>
<TD NOWRAP CLASS="eqno" WIDTH="10" ALIGN="RIGHT">
(<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">9</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>

<P>
ここで関数<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img342.png"
 ALT="$ A$"></SPAN>はfeatureからabstract featureへのマッピングであり、<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img343.png"
 ALT="$ R$"></SPAN>はabstract featureに対して定義されている。

<P>
AZHはパラメータとしてabstract featureを設定しなければならない。
Abstract featureを自動的に生成する手法は複数提案されており、最もシンプルなものはGreedy abstract feature generation [<A
 HREF="textbook.html#jinnai2016automated">16</A>]である。

<P>
Domain transition graph

<P>
Abstract featureの生成方法としてstate-of-the-artの手法はGraph partitioning-based [<A
 HREF="textbook.html#jinnai2017work">17</A>]であり、各DTGを与えられた最適化指標下で分割することでabstract featureを生成する。

<P>

<H1><A NAME="SECTION00870000000000000000"></A>
<A NAME="sec:novelty-based-pruning"></A><BR>
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN> 新奇性に基づく枝刈り (Novelty-based Pruning)
</H1>

<P>
新奇性に基づいて枝刈りを行う。

<P>

<H2><A NAME="SECTION00871000000000000000"></A>
<A NAME="sec:novelty"></A><BR>
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> 状態の新奇性 (Novelty)
</H2>

<P>

<H2><A NAME="SECTION00872000000000000000"></A>
<A NAME="sec:width-based-search"></A><BR>
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN> Width-Based Search (幅制限探索)
</H2>

<P>

<H2><A NAME="SECTION00873000000000000000"></A>
<A NAME="sec:iterative-width-search"></A><BR>
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">3</SPAN> Iterative Width Search (反復幅制限探索)
</H2>

<P>

<H2><A NAME="SECTION00874000000000000000"></A>
<A NAME="sec:width-based-heuristic-search"></A><BR>
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN> Best-First Width Search (最良優先幅制限探索)
</H2>

<P>

<H2><A NAME="SECTION00875000000000000000"></A>
<A NAME="sec:novelty-heuristics"></A><BR>
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN> Novelty Heuristics (新奇性に基づくヒューリスティック)
</H2>

<P>
<BR>

<H2><A NAME="SECTION00900000000000000000">
Index</A>
</H2><DL COMPACT>
<DT><STRONG>A* search</STRONG>
<DD><A HREF="textbook.html#842"><SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN></A>
<DT><STRONG>A*探索</STRONG>
<DD><A HREF="textbook.html#841"><SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN></A>
<DT><STRONG>BDD</STRONG>
<DD><A HREF="textbook.html#853"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN></A>
<DT><STRONG>Binary Decision Diagram</STRONG>
<DD><A HREF="textbook.html#852"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN></A>
<DT><STRONG>branching factor</STRONG>
<DD><A HREF="textbook.html#829"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN></A>
<DT><STRONG>deterministic</STRONG>
<DD><A HREF="textbook.html#793"><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN></A>
<DT><STRONG>Dijkstra's Algorithm</STRONG>
<DD><A HREF="textbook.html#839"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN></A>
<DT><STRONG>duplicate</STRONG>
<DD><A HREF="textbook.html#833"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN></A>
<DT><STRONG>duplicate detection</STRONG>
<DD><A HREF="textbook.html#836"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN></A>
<DT><STRONG>explicit state-space graph</STRONG>
<DD><A HREF="textbook.html#817"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN></A>
<DT><STRONG>grid path-finding problem</STRONG>
<DD><A HREF="textbook.html#823"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN></A>
<DT><STRONG>heuristic function</STRONG>
<DD><A HREF="textbook.html#845"><SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN></A>
<DT><STRONG>implicit state-space graph</STRONG>
<DD><A HREF="textbook.html#820"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN></A>
<DT><STRONG>lookahead</STRONG>
<DD><A HREF="textbook.html#787"><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN></A>
<DT><STRONG>Manhattan distance heuristic</STRONG>
<DD><A HREF="textbook.html#848"><SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN></A>
<DT><STRONG>Multiple Sequence Alignment</STRONG>
<DD><A HREF="textbook.html#826"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN></A>
<DT><STRONG>observation</STRONG>
<DD><A HREF="textbook.html#799"><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN></A>
<DT><STRONG>partial infomation</STRONG>
<DD><A HREF="textbook.html#796"><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN></A>
<DT><STRONG>path cost</STRONG>
<DD><A HREF="textbook.html#811"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN></A>
<DT><STRONG>perfect information</STRONG>
<DD><A HREF="textbook.html#790"><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN></A>
<DT><STRONG>solution</STRONG>
<DD><A HREF="textbook.html#808"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN></A>
<DT><STRONG>state-space graph</STRONG>
<DD><A HREF="textbook.html#805"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN></A>
<DT><STRONG>state-space problem</STRONG>
<DD><A HREF="textbook.html#802"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN></A>
<DT><STRONG>unit-cost</STRONG>
<DD><A HREF="textbook.html#814"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN></A>
<DT><STRONG>グリッド経路探索問題</STRONG>
<DD><A HREF="textbook.html#822"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN></A>
<DT><STRONG>ダイクストラ法</STRONG>
<DD><A HREF="textbook.html#838"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN></A>
<DT><STRONG>ヒューリスティック関数</STRONG>
<DD><A HREF="textbook.html#844"><SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN></A>
<DT><STRONG>マンハッタン距離ヒューリスティック</STRONG>
<DD><A HREF="textbook.html#847"><SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN></A>
<DT><STRONG>ユニットコスト</STRONG>
<DD><A HREF="textbook.html#813"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN></A>
<DT><STRONG>不完全情報</STRONG>
<DD><A HREF="textbook.html#795"><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN></A>
<DT><STRONG>先読み</STRONG>
<DD><A HREF="textbook.html#786"><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN></A>
<DT><STRONG>分枝度</STRONG>
<DD><A HREF="textbook.html#828"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN></A>
<DT><STRONG>多重整列問題</STRONG>
<DD><A HREF="textbook.html#825"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN></A>
<DT><STRONG>完全情報</STRONG>
<DD><A HREF="textbook.html#789"><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN></A>
<DT><STRONG>明示的状態空間グラフ</STRONG>
<DD><A HREF="textbook.html#816"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN></A>
<DT><STRONG>決定論的</STRONG>
<DD><A HREF="textbook.html#792"><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN></A>
<DT><STRONG>状態空間グラフ</STRONG>
<DD><A HREF="textbook.html#804"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN></A>
<DT><STRONG>状態空間問題</STRONG>
<DD><A HREF="textbook.html#801"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN></A>
<DT><STRONG>経路コスト</STRONG>
<DD><A HREF="textbook.html#810"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN></A>
<DT><STRONG>観察</STRONG>
<DD><A HREF="textbook.html#798"><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN></A>
<DT><STRONG>解</STRONG>
<DD><A HREF="textbook.html#807"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN></A>
<DT><STRONG>重複</STRONG>
<DD><A HREF="textbook.html#832"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN></A>
<DT><STRONG>重複検出</STRONG>
<DD><A HREF="textbook.html#835"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN></A>
<DT><STRONG>非明示的状態空間グラフ</STRONG>
<DD><A HREF="textbook.html#819"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN></A>

</DL>

<P>

<P>

<H2><A NAME="SECTION001000000000000000000">
Bibliography</A>
</H2><DL COMPACT><DD>urlstyle

<P></P><DT><A NAME="aeronautiques1998pddl">1</A>
<DD>
Aeronautiques, C., Howe, A., Knoblock, C., McDermott, I.D., Ram, A., Veloso,
  M., Weld, D., SRI, D.W., Barrett, A., Christianson, D., et&nbsp;al.: Pddl—the
  planning domain definition language version 1.2  (1998)

<P></P><DT><A NAME="algfoor2015comprehensive">2</A>
<DD>
Algfoor, Z.A., Sunar, M.S., Kolivand, H.: A comprehensive study on pathfinding
  techniques for robotics and video games.
<BR>International Journal of Computer Games Technology <SPAN  CLASS="textbf">2015</SPAN>, 7
  (2015)

<P></P><DT><A NAME="applegate2006traveling">3</A>
<DD>
Applegate, D.L.: The traveling salesman problem: a computational study.
<BR>Princeton University Press (2006)

<P></P><DT><A NAME="asai2014fully">4</A>
<DD>
Asai, M., Fukunaga, A.: Fully automated cyclic planning for large-scale
  manufacturing domains.
<BR>In: Proc. ICAPS (2014)

<P></P><DT><A NAME="burnslrz10">5</A>
<DD>
Burns, E., Lemons, S., Ruml, W., Zhou, R.: Best-first heuristic search for
  multicore machines.
<BR>Journal of Artificial Intelligence Research (JAIR) <SPAN  CLASS="textbf">39</SPAN>,
  689-743 (2010)

<P></P><DT><A NAME="culberson1997sokoban">6</A>
<DD>
Culberson, J.: Sokoban is pspace-complete  (1997)

<P></P><DT><A NAME="dijkstra1959note">7</A>
<DD>
Dijkstra, E.W.: A note on two problems in connexion with graphs.
<BR>Numerische mathematik <SPAN  CLASS="textbf">1</SPAN>(1), 269-271 (1959)

<P></P><DT><A NAME="edelkamp:2010:hst:1875144">8</A>
<DD>
Edelkamp, S., Schroedl, S.: Heuristic Search: Theory and Applications.
<BR>Morgan Kaufmann Publishers Inc., San Francisco, CA, USA (2010)

<P></P><DT><A NAME="edgar2006multiple">9</A>
<DD>
Edgar, R.C., Batzoglou, S.: Multiple sequence alignment.
<BR>Current opinion in structural biology <SPAN  CLASS="textbf">16</SPAN>(3), 368-373 (2006)

<P></P><DT><A NAME="erdem2005genome">10</A>
<DD>
Erdem, E., Tillier, E.: Genome rearrangement and planning.
<BR>In: Proc. AAAI, pp. 1139-1144 (2005)

<P></P><DT><A NAME="fikes:71">11</A>
<DD>
Fikes, R.E., Nilsson, N.: STRIPS: A New Approach to the Application
  of Theorem Proving to Problem Solving.
<BR>Artificial Intelligence <SPAN  CLASS="textbf">5</SPAN>(2), 189-208 (1971)

<P></P><DT><A NAME="held1970traveling">12</A>
<DD>
Held, M., Karp, R.M.: The traveling-salesman problem and minimum spanning
  trees.
<BR>Operations Research <SPAN  CLASS="textbf">18</SPAN>(6), 1138-1162 (1970)

<P></P><DT><A NAME="helmert2010scanalyzer">13</A>
<DD>
Helmert, M., Lasinger, H.: The scanalyzer domain: Greenhouse logistics as a
  planning problem.
<BR>In: Proc. ICAPS (2010)

<P></P><DT><A NAME="helmert:08">14</A>
<DD>
Helmert, M., Roger, G.: How good is almost perfect?
<BR>In: Proceedings of the 23rd National Conference on Artificial
  Intelligence AAAI-08, pp. 944-949 (2008)

<P></P><DT><A NAME="jinnai2016structured">15</A>
<DD>
Jinnai, Y., Fukunaga, A.: Abstract Zobrist hash: An efficient work
  distribution method for parallel best-first search.
<BR>In: Proc. AAAI, pp. 717-723 (2016)

<P></P><DT><A NAME="jinnai2016automated">16</A>
<DD>
Jinnai, Y., Fukunaga, A.: Automated creation of efficient work distribution
  functions for parallel best-first search.
<BR>In: Proc. ICAPS (2016)

<P></P><DT><A NAME="jinnai2017work">17</A>
<DD>
Jinnai, Y., Fukunaga, A.: On work distribution functions for parallel
  best-first search.
<BR>Journal of Artificial Intelligence Research (JAIR)  (2017).
<BR>(to appear)

<P></P><DT><A NAME="johnson1879notes">18</A>
<DD>
Johnson, W.W., Story, W.E., et&nbsp;al.: Notes on the” 15” puzzle.
<BR>American Journal of Mathematics <SPAN  CLASS="textbf">2</SPAN>(4), 397-404 (1879)

<P></P><DT><A NAME="kautz:92">19</A>
<DD>
Kautz, H., Selman, B.: Planning as Satisfiability.
<BR>In: ECAI, pp. 359-363 (1992)

<P></P><DT><A NAME="kishimotofb13">20</A>
<DD>
Kishimoto, A., Fukunaga, A., Botea, A.: Evaluation of a simple, scalable,
  parallel best-first search strategy.
<BR>Artificial Intelligence <SPAN  CLASS="textbf">195</SPAN>, 222-248 (2013).
<BR>DOI&nbsp;
  rm10.1016/j.artint.2012.10.007.
<BR>
  URL <TT><A NAME="tex2html22"
  HREF="http://linkinghub.elsevier.com/retrieve/pii/S0004370212001294">http://linkinghub.elsevier.com/retrieve/pii/S0004370212001294</A></TT>
<P></P><DT><A NAME="korf:85a">21</A>
<DD>
Korf, R.: Depth-first iterative deepening: An optimal admissible tree search.
<BR>Artificial Intelligence <SPAN  CLASS="textbf">97</SPAN>, 97-109 (1985)

<P></P><DT><A NAME="korf:2000">22</A>
<DD>
Korf, R.E., Zhang, W.: Divide-and-conquer frontier search applied to optimal
  sequence alignment.
<BR>In: Proceedings of the 17th National Conference on Artificial
  Intelligence AAAI-00, pp. 910-916 (2000)

<P></P><DT><A NAME="lipovetzky2015a">23</A>
<DD>
Lipovetzky, N., Ramirez, M., Geffner, H.: Classical planning with simulators:
  Results on the Atari video games.
<BR>In: Proc. IJCAI, pp. 1610-1616 (2015)

<P></P><DT><A NAME="mcdowell2011cracking">24</A>
<DD>
McDowell, G.L.: Cracking the coding interview.
<BR>CarrerCup (2011)

<P></P><DT><A NAME="mcquillan1980new">25</A>
<DD>
McQuillan, J., Richer, I., Rosen, E.: The new routing algorithm for the
  arpanet.
<BR>IEEE Transactions on Communications <SPAN  CLASS="textbf">28</SPAN>(5), 711-719 (1980)

<P></P><DT><A NAME="nash2007theta">26</A>
<DD>
Nash, A., Daniel, K., Koenig, S., Felner, A.: Theta^*: Any-angle path
  planning on grids.
<BR>In: Proc. AAAI, pp. 1177-1183 (2007)

<P></P><DT><A NAME="pearl84">27</A>
<DD>
Pearl, J.: Heuristics - Intelligent Search Strategies for Computer Problem
  Solving.
<BR>Addison-Wesley (1984)

<P></P><DT><A NAME="pearson1990">28</A>
<DD>
Pearson, W.R.: Rapid and sensitive sequence comparison with FASTP and
  FASTA.
<BR>Methods in enzymology <SPAN  CLASS="textbf">183</SPAN>, 63-98 (1990).
<BR>Matrix score is available at
  http://prowl.rockefeller.edu/aainfo/pam250.htm

<P></P><DT><A NAME="russelln03">29</A>
<DD>
Russell, S., Norvig, P.: Artificial Intelligence: A Modern Approach, 2nd
  edition edn.
<BR>Prentice-Hall, Englewood Cliffs, NJ (2003)

<P></P><DT><A NAME="skiena2006programming">30</A>
<DD>
Skiena, S.S., Revilla, M.A.: Programming challenges: The programming contest
  training manual.
<BR>Springer Science &amp; Business Media (2006)

<P></P><DT><A NAME="sousa2013toward">31</A>
<DD>
Sousa, A., Tavares, J.: Toward automated planning algorithms applied to
  production and logistics.
<BR>IFAC Proceedings Volumes <SPAN  CLASS="textbf">46</SPAN>(24), 165-170 (2013)

<P></P><DT><A NAME="sturtevant2012benchmarks">32</A>
<DD>
Sturtevant, N.R.: Benchmarks for grid-based pathfinding.
<BR>IEEE Transactions on Computational Intelligence and AI in Games
  <SPAN  CLASS="textbf">4</SPAN>(2), 144-148 (2012)

<P></P><DT><A NAME="yap2002grid">33</A>
<DD>
Yap, P.: Grid-based path-finding.
<BR>In: Conference of the Canadian Society for Computational Studies of
  Intelligence, pp. 44-55. Springer (2002)

<P></P><DT><A NAME="zobrist:70">34</A>
<DD>
Zobrist, A.L.: A new hashing method with applications for game playing.
<BR>Tech. rep., Dept of CS, Univ. of Wisconsin, Madison (1970).
<BR>Reprinted in <I>International Computer Chess Association Journal</I>,
  13(2):169-173, 1990
</DL>

<H1><A NAME="SECTION001100000000000000000">
About this document ...</A>
</H1>
 <p>
This document was generated using latex2html and this process may
have produced partially erroneous output, including missing figures,
missing formulas, unnumbered figures, and broken links.  The PDF files
at <a href="https://sites.google.com/site/yuujinnaishomepage/jp/graph-search-algorithm">my webpage</a>
are a more reliable source.
</p>

<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot56">... Rationallyを実現するための技術である</A><A
 HREF="textbook.html#tex2html1"><SUP><SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN></SUP></A></DT>
<DD>探索は４つ全てに強く関係しているが本書は主にThink Rationallyに注視する

</DD>
<DT><A NAME="foot718">...Web上に簡単に試せるデモがあるので、参照されたい</A><A
 HREF="textbook.html#tex2html4"><SUP><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN></SUP></A></DT>
<DD><TT><A NAME="tex2html5"
  HREF="http://qiao.github.io/PathFinding.js/visual/">http://qiao.github.io/PathFinding.js/visual/</A></TT>

</DD>
<DT><A NAME="foot719">...#tex2html_wrap_inline4222#</A><A
 HREF="textbook.html#tex2html7"><SUP><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN></SUP></A></DT>
<DD>スライディングタイルは偶奇性があり、到達不可能な状態がある[<A
 HREF="textbook.html#johnson1879notes">18</A>]。

</DD>
<DT><A NAME="foot726">...
木探索はオープンリスト</A><A
 HREF="textbook.html#tex2html11"><SUP><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN></SUP></A></DT>
<DD>歴史的な経緯でリストと呼ばれているが、データ構造がリストで実装されるという意味ではない。効率的なデータ構造は<A HREF="#ch:search-performance">6</A>章で紹介する。

</DD>
<DT><A NAME="foot336">...<B>緩和問題</B>を解き、その最適解コストをヒューリスティック値とすることである。ある問題の緩和問題とは、解集合に元の問題の解を含む問題を指す。要するに元の問題より簡単な問題である</A><A
 HREF="textbook.html#tex2html12"><SUP><SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN></SUP></A></DT>
<DD>解が多いほど簡単であるとは一概には言えないが

</DD>
<DT><A NAME="foot401">...<B>緩和問題</B>を解き、その最適解コストをヒューリスティック値とすることである。ある問題の緩和問題とは、解集合に元の問題の解を含む問題を指す。要するに元の問題より簡単な問題である</A><A
 HREF="textbook.html#tex2html13"><SUP><SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN></SUP></A></DT>
<DD>解が多いほど簡単であるとは一概には言えないが

</DD>
<DT><A NAME="foot625">...
効率的なGPU並列化アルゴリズムの開発は大きな成果が期待されるブルーオーシャンであるといえる</A><A
 HREF="textbook.html#tex2html21"><SUP><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN></SUP></A></DT>
<DD>個人の感想である

</DD>
</DL>
<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive" SRC="nx_grp_g.png"> 
<A NAME="tex2html23"
  HREF="https://sites.google.com/site/yuujinnaishomepage/jp/graph-search-algorithm">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev_g.png">   
<BR>
<B> Up:</B> <A NAME="tex2html24"
  HREF="https://sites.google.com/site/yuujinnaishomepage/jp/graph-search-algorithm">Yuu Jinnai</A></DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<a href="https://sites.google.com/site/yuujinnaishomepage/jp/graph-search-algorithm">Yuu Jinnai</a>
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-5860680-3']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript';ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>

</ADDRESS>
</BODY>
</HTML>
